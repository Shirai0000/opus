////////////////////////////////////////////////
///
///
///
///
////////////////////////////////////////////////
#include "DxLib.h"
#include <Windows.h>
#include <time.h>
#include <math.h>
#include "mainloop.h"
#include "game.h"
#include "result.h"

#define MOJICODE   (4)//アイテム数
#define MOJISUU   (20)//指定した文字数
#define UP    (1)     //上
#define DOWN  (3)     //下
#define RIGHT (2)     //右

#define LEFT  (4)     //左
//最大コマンド数
#define COMMAND  (10)
//スキル数
#define SKILLSUU (4)

#define ENROUTE (280) 　　//攻撃途中のカウント


#define ZAKOSPEED (0.01)
//点滅時間
#define BLINKING   (180)
#define ghnumber   (40)      //画像数

#define bgmnumber   (10)     //bgm数

#define PLAYERINVINCIBLETIMENUMBER    (120)    //無敵時間


typedef struct
{
	char moji[48][3];   //文字ブロック
	int  mojisuutate[48];  //文字ブロックたて
	int  mojisuuyoko[48];  //文字ブロック横
	char code[MOJISUU];   //比較する単語
	char tama[5][3];      //プレイヤーが発射する弾
	int  tamaX[5];        //弾x軸        
	int tamaY[5];        //弾y軸
	int aitemX;          //アイテムx軸
	int aitemY;          //アイテムy軸
	int myaitem;         //出現しているアイテム
	int weapon;         //アイテムの種類
	int oldaitemX;     //アイテムがあったx軸
	int oldaitemY;     //アイテムがあったy軸
	int durable;       // 耐久値
	int direction[5];   //弾が飛んでいく方向
	int ride;           //文字ブロックに乗っているのか
	int frozen;         //文字ブロックと重なり動けない状態のカウント
	int Appearance[48]; //点滅しているか
	int tamascrollX[5]; //スクロールする前のx軸
	int tamascrollY[5]; //スクロールする前のy軸
	int have;           //アイテムを持っているのか
	int Playerlife;      //プレイヤーのライフ
	int Playerinvincible;  //プレイヤー無敵状態
	int Playerinvincibletime;   //プレイヤー無敵時間
	int Waitingtime;            //待ち時間
	int weaponsuu;              //持っているアイテム
	int yumi;

}MOJI;

typedef struct
{
	char letter[MAPTATE][3];//固定位置の文字ブロック

}MAPMOJI;


typedef struct
{
	int enemytype;        //敵の種類
	double enemyX;        //敵X
	double enemyY;        //敵Y
	int Widthofaction;    //行動パターン
	char enemyname[20];   //名前
	int  enemyLife;       //体力値
	double oldenemyX;
	double oldenemyY;
	int enemyballetX;     //弾X
	int enemyballetY;     //弾Y
	int enemydirection;   //敵が向いている方向
	int timer;              //攻撃までの時間
	int waittimer;
	int appearanceX;
	int appearanceY;
	int Attackrange[10];       //攻撃範囲
	int Attacktimer;       //攻撃までの準備時間
	int AttackSustain[10];  //攻撃継続時間
	int Attackmiddle;       //攻撃中
	int OldLife;            //以前の体力値
	int enemyinvincible;    //敵無敵状態
	int enemyinvincibletime; //敵無敵時間
	int MAXLife;
	int starttime;
	char enemycode[MOJISUU];
	int finishtime;
}ENEMY;

typedef struct
{
	float m_PosX;		// 描画座標X
	float m_PosY;		// 描画座標Y
	float m_Radius;		// 半径(描画用)
	float m_CenterX;	// 中心座標X
	float m_CenterY;	// 中心座標Y
	int m_Angle;		// 角度
	float m_Length;		// 半径の長さ
	int rotate;
	int oldrotate;
}SERECT;

typedef struct
{
	int old[2];
	int goalup;
	int goaldawn;
	int goallen;
	double hpbarLEFT;
	double hpbarRIGHT;
	double hpbarUP;
	double hpbarDAWN;
	int enemyimageLEFT;
	int enemyimageRIGHT;
	int enemyimageUP;
	int enemyimageDAWN;
	int LIFE;
	int goalappearanceX;        //ゴールを出現させるX座標
	int goalappearanceY;        //ゴールを出現させるY座標
}SCREEN;

typedef struct
{
	int gh[ghnumber];   //画像
}IMAGE;

typedef struct
{
	int  BGM[bgmnumber];           //BGM
}MUSIC;



int gamescreen[MAPYOKO][MAPTATE] =
{
	{ 0, 0, 0, 0, 0, 0, 0, 45, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 10, 10, 10, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 15, 0} ,
	{ 0, 10, 10, 10, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 10, 10, 10, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,


	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 40, 40, 40, 40, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 73, 71, 70, 0, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 70, 0, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 70, 0, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,

	{ 0, 0, 70, 0, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 70, 0, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 70, 0, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 70, 0, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 74} ,
	{ 0, 0, 70, 0, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 70, 0, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 74} ,
			   
	{ 0, 0, 70, 0, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 72, 72, 72, 72, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 74} ,
	{ 72, 72, 72, 72, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 72, 72, 72, 72, 40, 0,0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 72, 72, 72, 72, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 16, 0, 0} ,
	{ 72, 72, 72, 72, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 72, 72, 72, 72, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,

	{ 40, 40, 40, 40, 40, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 14,0,0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,


};


int MAP1_1[MAPYOKO][MAPTATE] =
{
	{ 0, 0, 0, 0, YUKA, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 90, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	  			  
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 90, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	  			  
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 90, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	  			  
	  			  
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 90, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	  			  
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 90, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	  			  
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 15, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,

};

//36
int MAP1_2[MAPYOKO][MAPTATE] =
{
	{0, 0, 0, 0, YUKA, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, YUKA, 0, 0, 0} ,
	{0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
													   
	{0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
																  
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
															   
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	  
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,

	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 16, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, YUKA, 0, 0, 0} ,


};


int MAP1_3[MAPYOKO][MAPTATE] =
{
	{ 0, 0, 0, 0, YUKA, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  92, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	  			  													 
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 91,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	  			  													 
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 92, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 91,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	  			  													 
	  			  													 
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 92,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 91,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	  	
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 91,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,

	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 92, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  17, 0, 0, 0, 0, 0, 0, 0, 0, 91,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,


};


int MAP1_4[MAPYOKO][MAPTATE] =
{
	{ 0, 0, 0, 0, YUKA, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
		  													 
			  													 
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
		 													 
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
		  													 
		  													 
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
			 													 
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,

	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 18,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
	{ 0, 0, 0, 0, YUKA, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,YUKA, 0, 0, 0} ,
};




int tutorial[MAPYOKO][MAPTATE] =
{
	{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,


	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 300, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,

	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,


	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,

	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 301,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0} ,
	{ 1, 0, 14, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0} ,
	{ 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0} ,

	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,

	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 302, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,

	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,


	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,

	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 303,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,

	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 304, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,


	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,

	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 30, 30, 30, 30, 30,  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,

	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  305, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0} ,
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 14, 0, 14, 0, 14, 1, 0, 0, 0} ,

	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },

	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  306, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },


	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 50, 50, 50, 1, 0, 0, 0 },
	{ 1, 0, 0, 0, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 },
	
};






//インプット関数
void Input(Key *);

void Draw(MOJI *,int *,int *,int *,int *,ENEMY *,int *,SERECT *,int *,int *,int *,int *,int *,int *,MAPMOJI *,int *,SCREEN *seen,int *mydirection,IMAGE *,INFORMATION *,MUSIC *);
//アウトプット関数
void Update(Key *,int *,int *,int *,int *,int *,int *,int *,MOJI *,int *,int *,int *,int *,int *,int *,MAPMOJI *,ENEMY *,int *,IMAGE *,SERECT *sere,SCREEN *,MUSIC *);

//フレームウエイト関数
void Framewait(void);

//比較関数
void comparison(MOJI *,int *,int *,int *,MAPMOJI *,int *,ENEMY *);

//敵関数
void teki(ENEMY *,int *,MOJI *,int *,int *,int *,int *,IMAGE *,SCREEN *seen);

void ui(MOJI *, ENEMY *,int *,int *,int *,int *,int *,int *,SCREEN *,IMAGE *);

void judgement(ENEMY *en, int *brox, MOJI*mi,int *,int *,IMAGE *);


int game(int *stage,INFORMATION *infor)
{
	


	if (DxLib_Init() == -1) return -1;	// ライブラリ初期化

	SetGraphMode(640, 480, 16);	// 画面設定
// 描画先画面を裏画面にする
	SetDrawScreen(DX_SCREEN_BACK);


	int myreturn = 0;

	//前の位置
	int OldkeyY = 0;
	int OldkeyX = 0;

	//ジャンプ値
	int jumppower = 0;

	//キー初期化
	Key key[1] = { 0,0,0,0,0 };
	int Key1;
	MOJI mi[64];
	ENEMY en[32];
	MAPMOJI maji[MAPYOKO];
	//画像
	IMAGE im =
	{
		 LoadGraph("kenn.png"),                   //アイテム_剣   0
		 LoadGraph("kyara.png")   ,               //キャラ右      1
		LoadGraph("kyara_LEFT.png"),               //キャラ左     2
		LoadGraph("background.png"),               //背景         3
		LoadGraph("mouse.png"),                     //雑魚敵      4
		LoadGraph("goal.png"),                //ゴール            5
		LoadGraph("hart.png"),                //ハート            6
		LoadGraph("jin.png"),                 //敵キャラ2右       7
		LoadGraph("jin_left.png"),            //敵キャラ2左       8
		LoadGraph("pegasus.png"),             //敵キャラ3左       9
		LoadGraph("pegasus_RIGHT.png"),       //敵キャラ3右       10
		LoadGraph("belial.png"),              //敵キャラ4正面     11
		LoadGraph("el_plasma.png"),           //弾                12 
		LoadGraph("wisp.png"),                //装飾              13 
		LoadGraph("umi.png"),                 //海背景            14
		LoadGraph("kumonoue.png"),            //雲の上背景        15
		LoadGraph("jigoku.png"),              //地獄背景          16
		LoadGraph("stone.png"),               //装飾              17
		LoadGraph("tate.png"),                //アイテム_盾       18
		LoadGraph("ga-do.png"),               //ハートガード      19
		LoadGraph("el_fire.png"),             //装飾              20
		LoadGraph("yumi.png"),                //アイテム_弓       21
		LoadGraph("yumi_RIGHT.png"),          //弓矢_右　　　　　 22
		LoadGraph("yumi_LEFT.png"),           //弓矢_左           23
		LoadGraph("balor.png"),               //敵キャラ11        24
		LoadGraph("bakudann.png"),             //アイテム_爆弾     25
		LoadGraph("bakudann_mae.png"),         //アイテム_爆弾起爆前　26
		LoadGraph("bakuha.png"),               //アイテム_爆発        27
		LoadGraph("go-ru.png"),                //ゴール               28
		LoadGraph("ken_yoko.png"),              //アイテム_剣_RIGHT　 29
		LoadGraph("ken_LEFT.png"),              //アイテム_剣_LEFT    30
		LoadGraph("sentaku.png"),               //選択肢枠            31  
		LoadGraph("mahounotue.png"),            //アイテム_杖_RIGHT   32
		LoadGraph("mahounotue_LEFT.png"),       //アイテム_杖_LEFT    33
		LoadGraph("nagarebosi.png"),            //流れ星              34
		LoadGraph("setumei.png"),               //説明                35
		LoadGraph("alpha.png"),                 //敵キャラ5           36
		LoadGraph("yami.png"),                  //1-4背景             37

	};


	MUSIC mu = 
	{
		LoadSoundMem("魔王魂戦闘曲2.mp3"),            //メイン曲   0
		LoadSoundMem("魔王魂ボス04.mp3"),             //メイン曲2  1
		LoadSoundMem("魔王魂ジングル07.mp3"),         //           2
		LoadSoundMem("魔王魂ジングル03.mp3"),         //           3
		LoadSoundMem("魔王魂戦闘14.mp3"),             //           4
		LoadSoundMem("魔王魂爆発03.mp3"),             //爆発音     5
	};

	//プレイヤー座標
	int PlayerX = 300;
	int PlayerY = 200;

	//コード作成
	char code[MOJICODE][MOJISUU] = {
		"たて",
		"ゆみ",
		"ばく",
		"けん",
	};

	char enemycode[MOJICODE][MOJISUU] = {
		"ばぐ",
	};
	//表示されている文字
	int brox = 0;


	//時間習得
	DATEDATA Date;
	GetDateTime(&Date);
	int timermin = 0;
	int timersec = 0;
	timermin = Date.Min;
	timersec = Date.Sec;
	//比較コード
	for (int len = 0; len < MOJICODE; len++)
	{
		
			for (int sen = 0; sen < 5; sen++)
			{
				mi[len].code[sen] = code[len][sen];
			}
	}

	SERECT sere =
	{
		640,
		480,
		50,
		600,
		480,
		0.0f,
		100.0f,
	};



	for (int len = 0; len < 32; len++)
	{
		for (int sen = 0; sen < 24; sen++)
		{
			mi[len].Appearance[sen] = -2;
			mi[len].mojisuutate[sen] = -2;
			mi[len].mojisuuyoko[sen] = -2;
			mi[len].weapon = -2;
			mi[len].aitemX = -2;
			mi[len].aitemY = -2;
			mi[len].direction[sen] = -2;
			mi[len].durable = -2;
			mi[len].have = -2;
			mi[len].weaponsuu = 0;
			mi[len].yumi = 0;
			mi[len].Waitingtime = -2;
			mi[len].tamascrollX[sen] = -2;
			mi[len].tamascrollY[sen] = -2;
		}
	}
	mi[0].frozen = -2;
	for (int sen = 0; sen < 32; sen++)
	{
		for (int len = 0; len < 5; len++)
		{
			mi[sen].tamaX[len] = -2;
			mi[sen].tamaY[len] = -2;
		}
	}
	for (int len = 0; len < MAPYOKO; len++)
	{
		for (int sen = 0; sen < MAPTATE; sen++)
		{
			maji[len].letter[sen][0] = -52;
		}
	}
	for (int len = 0; len < 32; len++)
	{
		for (int sen = 0; sen < 10; sen++)
		{
			en[len].enemytype = -2;
			en[len].enemyX = -2;
			en[len].enemyY = -2;
			en[len].Widthofaction = -2;
			en[len].enemyballetX = -2;
			en[len].enemyballetY = -2;
			en[len].enemydirection = -2;
			en[len].appearanceX = -2;
			en[len].appearanceY = -2;
			en[len].timer = -2;
			en[len].enemyinvincible = 0;
			en[len].enemyinvincibletime = 0;
			en[len].Attackmiddle = -1;
			en[len].Attackrange[sen] = -2;
			en[len].AttackSustain[sen] = -2;
			en[len].enemyLife = -2;
			en[len].OldLife = -2;
			en[len].MAXLife = -2;
			en[len].waittimer = -2;
			en[len].Attacktimer = -2;
			en[len].finishtime = -2;
			en[len].starttime = -2;
			en[len].oldenemyX = -2;
			en[len].oldenemyY = -2;
		}
	}

	mi[0].Playerlife = 3;
	mi[0].Playerinvincible = 0;
	mi[0].Playerinvincibletime = 0;
	en[0].finishtime = -2;

	//初期文字割り当て
		for (int len = 0; len < 32; len++)
		{
			for (int sen = 0; sen < 24; sen++)
			{
				char ranmoji[93];
				int random = 0;
				int randam = 0;
				switch (*stage)
				{
				case  0:
					randam = 3;
					{
						char ranmoji0[3] = { "ん" };
						for (int men = 0; men < random; men++)
						{
							ranmoji[men] = ranmoji0[men];
						}
					}
					break;
				case  11:
					random = 9;
					{
						char ranmoji11[9] = { "けんばく" };
						for (int men = 0; men < random; men++)
						{
							ranmoji[men] = ranmoji11[men];
						}
					}
					break;
				case 12:
					random = 13;
					{
						char ranmoji12[13] = { "たてゆみばく" };
						for (int men = 0; men < random; men++)
						{
							ranmoji[men] = ranmoji12[men];
						}
					}
					break;
				case 13:
					random = 11;
					{
						char ranmoji13[11] = { "けんばくぐ" };
						for (int men = 0; men < random; men++)
						{
							ranmoji[men] = ranmoji13[men];
						}
					}
					break;
				case   14:
					random = 19;
					{
						char ranmoji14[19] = { "けんたてばくぐゆみ" };
						for (int men = 0; men < random; men++)
						{
							ranmoji[men] = ranmoji14[men];
						}
					}
					break;
				}

					randam = GetRand(random - 2);

					mi[len].moji[sen][2] = ranmoji[random - 1];
					if (!(randam == 0))
					{
						if (randam % 2 == 1)
						{
							randam--;
						}
					}

					for (int men = 0; men < 2; men++)
					{
						mi[len].moji[sen][men] = ranmoji[randam + men];
					}
			}
		}

		mi[0].ride = 0;
	
	//前の時間
	int retime = 0;
	//弾発射間隔
	int ballettime = 0;
	//表示する時間
	int timer = 0;
	//弾方向
	int mydirection = 2;
	



	//弾の位置を初期化
	for (int len = 0; len < 5; len++)
	{
		mi[0].tamaX[len] = -1;
		mi[0].tamaY[len] = -1;
	}
	//弾初期化
	char z = 'z';
	for (int len = 0; len < 5; len++)
	{
		mi[0].tama[len][0] = z;
	}
	int breaktime;
	int scrollX = 0;
	int scrollY = 0;


	int shockwave = 0;

	SCREEN seen[AFTIMAGENUM];


	seen->goalappearanceX = -1;
	seen->goalappearanceY = -1;
	seen->enemyimageDAWN = -2;
	seen->enemyimageLEFT = -2;
	seen->enemyimageRIGHT = -2;
	seen->enemyimageUP = -2;
	seen->goalappearanceX = -2;
	seen->goalappearanceY = -2;
	seen->goaldawn = -2;
	seen->goallen = -2;
	seen->goalup = -2;
	seen->goalup = -2;
	seen->hpbarDAWN = -2;
	seen->hpbarLEFT = -2;
	seen->hpbarRIGHT = -2;
	seen->hpbarUP = -2;
	seen->LIFE = -2;
	seen->old[0] = -2;
	seen->old[1] = -2;
	int Key;
	
	


	//曲再生
	if ((*stage == 0) || (*stage == 11) || (*stage == 12))
	{
		PlaySoundMem(mu.BGM[0], DX_PLAYTYPE_LOOP, TRUE);
	}
	if ((*stage == 13) || (*stage == 14))
	{
		PlaySoundMem(mu.BGM[1], DX_PLAYTYPE_LOOP, TRUE);

	}
	// メインループ
	while (ProcessMessage() == 0 && CheckHitKey(KEY_INPUT_ESCAPE) == 0 && myreturn == 0)
	{
		//StopSoundMem(mu.BGM[0]);
		//インプット関数
		Input(key);

		//アップデート関数
		Update(key,&timer,&PlayerX,&PlayerY,&OldkeyX,&OldkeyY,&jumppower,&brox,mi,&retime,&ballettime,&mydirection,stage,&scrollX,&scrollY,maji,en,&myreturn,&im,&sere,seen,&mu);

        //draw関数
		Draw(mi,&retime,&brox,&PlayerX,&PlayerY,en,&breaktime,&sere,&timersec,&timermin,stage,&scrollX,&scrollY,&shockwave,maji,&myreturn,seen,&mydirection,&im,infor,&mu);

		//フレームウエイト関数
		Framewait();

		//キー入力を得る
		Key1 = GetJoypadInputState(DX_INPUT_KEY_PAD1);


		//画面消す
		ClearDrawScreen();

	}
	//曲停止
	if ((*stage == 0) || (*stage == 11) || (*stage == 12))
	{
		StopSoundMem(mu.BGM[0]);

	}
	if ((*stage == 13) || (*stage == 14))
	{
		StopSoundMem(mu.BGM[1]);

	}
	DeleteSoundMem(mu.BGM[0]);	//破棄
	DeleteSoundMem(mu.BGM[1]);  //破棄

	return myreturn;
}

//キー
void Input(Key *key)
{
	key[0].KeyUp = CheckHitKey(KEY_INPUT_UP);                    //上キーが押された場合
	key[0].KeyDown = CheckHitKey(KEY_INPUT_DOWN);                //下キーが押された場合
	key[0].KeyReturn = CheckHitKey(KEY_INPUT_RETURN);            //リターンキーが押された場合
	key[0].KeyRight = CheckHitKey(KEY_INPUT_RIGHT);             //右キーが押された場合
	key[0].KeyLeft = CheckHitKey(KEY_INPUT_LEFT);                //左キーが押された場合
	key[0].KeyZ = CheckHitKey(KEY_INPUT_Z);                      //zキーが押された場合
	key[0].KeyA = CheckHitKey(KEY_INPUT_A);                      //aキーが押された場合
	key[0].KeyR = CheckHitKey(KEY_INPUT_R);                      //rキーが押された場合
}


void Update(Key *key, int *timer, int *PlayerX, int *PlayerY, int *OldkeyX, int *OldkeyY, int *jumppower, int *brox, MOJI *mi, int *retime, int *ballettime, int *mydirection, int *stage, int *scrollX, int *scrollY, MAPMOJI *maji, ENEMY *en,int *myreturn,IMAGE *im,SERECT *sere,SCREEN *seen,MUSIC *mu)
{
	//海背景
	if (*stage == 11)
	{
		DrawExtendGraph(0, 0, 640, 480, im->gh[14], TRUE);
	}
	//雲の上背景
	if (*stage == 12)
	{
		DrawExtendGraph(0, 0, 640, 480, im->gh[15], TRUE);
	}
	//地獄背景
	if (*stage == 13)
	{
		DrawExtendGraph(0, 0, 640, 480, im->gh[16], TRUE);
	}
	if (*stage == 14)
	{
		DrawExtendGraph(0, 0, 640, 480, im->gh[37], TRUE);
	}
	int MouseXPos, MouseYPos;
	//マウスの座標を取得
	GetMousePoint(&MouseXPos, &MouseYPos);
	int shoot = 0;
	

	if (en[0].finishtime < -1)
	{
		if (key[0].KeyDown == 1)*PlayerY += 3, mi[0].ride = 0;    //下キーが押された場合
		if (key[0].KeyLeft == 1) *mydirection = LEFT, mi[0].ride = 0, *PlayerX -= 3;   //左キーが押された場合
		if (key[0].KeyRight == 1)*mydirection = RIGHT, mi[0].ride = 0, *PlayerX += 3;   //右キーが押された場合
		if (key[0].KeyUp == 1)mi[0].ride = 0;                    //上キーが押された場合
		if (key[0].KeyZ == 1)shoot = 1;                            //zキーが押された場合
		if (key[0].KeyR == 1)                                      //rキーが押された場合
		{
			if (mi[0].ride == 0)
			{
				mi[0].ride = 1;
			}

		}
	}

	if (!(*PlayerX == CENTERX))
	{
		if (*PlayerX > CENTERX)
		{
			int s = 0;
			s = *PlayerX - CENTERX;
			*scrollX -= s;
			*PlayerX = CENTERX;
		}
		if (*PlayerX < CENTERX)
		{
			int r = 0;
			r = CENTERX - *PlayerX;
			*scrollX += r;
			*PlayerX = CENTERX;
		}

	}


	
	
		//プレイヤー無敵時間
		if (mi[0].Playerinvincibletime > 0)
		{
			--mi[0].Playerinvincibletime;
		}
		else
		{
			//無敵時間が終わったら、無敵状態をとく
			mi[0].Playerinvincible = 0;
		}
		for (int len = 0; len < 32; len++)
		{
			if (en[len].enemyinvincibletime > 0)
			{
				--en[len].enemyinvincibletime;
			}
			else
			{
				en[len].enemyinvincible = 0;
			}
		}


		//ジャンプ
			// 落下処理36
		*PlayerY -= *jumppower;

		// 落下加速度を加える
		*jumppower -= 1;
	
	// もし地面についていたら止まる
	if (*PlayerY > 380)
	{
		*PlayerY = 380;
		*jumppower = 0;
	}
	//天井
	if (*PlayerY < 100)
	{
		*PlayerY = 100;
	}

	// ジャンプボタンを押していて、地面についていたらジャンプ
	if (CheckHitKey(KEY_INPUT_RETURN) && *PlayerY == *OldkeyY) *jumppower = 10;


	//当たり判定
	int sen = 0;
	for (int hen = 0; hen * 24 < *brox; hen++)
	{
		for (sen = 0; hen * 24 + sen < *brox&&sen < 24; sen++)
		{
			if (mi[hen].Appearance[sen] == 0)
			{
				if ((mi[hen].mojisuutate[sen] * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (mi[hen].mojisuutate[sen] + 1) * 20 + *scrollX) && (mi[hen].mojisuuyoko[sen] * 20 <= *PlayerY + 20) && (*PlayerY <= (mi[hen].mojisuuyoko[sen] + 1) * 20))
				{
					//文字ブロックに当たったら前の座標に戻る
					*scrollX = *OldkeyX;
					*PlayerY = *OldkeyY;
					*jumppower = 0;         //ジャンプしていない状態

					//前の座標も文字ブロックに当たっていた時(つんだ状態)の処理
					if ((mi[hen].mojisuutate[sen] * 20 + *OldkeyX <= *PlayerX + 20) && (*PlayerX <= (mi[hen].mojisuutate[sen] + 1) * 20 + *OldkeyX) && (mi[hen].mojisuuyoko[sen] * 20 <= *OldkeyY + 20) && (*OldkeyY <= (mi[hen].mojisuuyoko[sen] + 1) * 20))
					{
						if (mi[0].frozen < -1)
						{
							mi[0].frozen = 40;
						}
						else
						{
							--mi[0].frozen;
						}
						if (mi[0].frozen == 0)
						{
							mi[0].frozen = -2;
							mi[hen].mojisuutate[sen] = -1;
							mi[hen].mojisuuyoko[sen] = -1;
						}

					}
				}
			}

		}
	}
	///////////////////////マップ当たり判定///////////////////////////////////////////
	//チュートリアル
	if (*stage == 0)
	{
		for (int len = 0; len < MAPYOKO; len++)
		{

			for (int sen = 0; sen < MAPTATE; sen++)
			{
				if (tutorial[len][sen] == 1)
				{
					if ((len * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (len + 1) * 20 + *scrollX) && (sen * 20 <= *PlayerY + 20) && (*PlayerY <= (sen + 1) * 20))
					{
						//文字ブロックに当たったら前の座標に戻る
						*scrollX = *OldkeyX;
						*PlayerY = *OldkeyY;
						*jumppower = 0;
					}
				}
				if (tutorial[len][sen] == 30)
				{
					if ((len * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (len + 1) * 20 + *scrollX) && (sen * 20 <= *PlayerY + 20) && (*PlayerY <= (sen + 1) * 20))
					{
						*scrollX = *OldkeyX;
						*PlayerY = *OldkeyY;
						*jumppower = 0;
					}
				}

			}
		}
	}

	////1-1
	if (*stage == 11)
	{
		for (int len = 0; len < MAPYOKO; len++)
		{

			for (int sen = 0; sen < MAPTATE; sen++)
			{
				if (MAP1_1[len][sen] == 1)
				{
					if ((len * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (len + 1) * 20 + *scrollX) && (sen * 20 <= *PlayerY + 20) && (*PlayerY <= (sen + 1) * 20))
					{
						//文字ブロックに当たったら前の座標に戻る
						*scrollX = *OldkeyX;
						*PlayerY = *OldkeyY;
						*jumppower = 0;
					}
				}
				if (MAP1_1[len][sen] == 30)
				{
					if ((len * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (len + 1) * 20 + *scrollX) && (sen * 20 <= *PlayerY + 20) && (*PlayerY <= (sen + 1) * 20))
					{
						*scrollX = *OldkeyX;
						*PlayerY = *OldkeyY;
						*jumppower = 0;
					}
				}

			}
		}
	}

	////1-2
	if (*stage == 12)
	{
		for (int len = 0; len < MAPYOKO; len++)
		{

			for (int sen = 0; sen < MAPTATE; sen++)
			{
				if (MAP1_2[len][sen] == 1)
				{
					if ((len * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (len + 1) * 20 + *scrollX) && (sen * 20 <= *PlayerY + 20) && (*PlayerY <= (sen + 1) * 20))
					{
						//文字ブロックに当たったら前の座標に戻る
						*scrollX = *OldkeyX;
						*PlayerY = *OldkeyY;
						*jumppower = 0;
					}
				}
				if (MAP1_2[len][sen] == 30)
				{
					if ((len * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (len + 1) * 20 + *scrollX) && (sen * 20 <= *PlayerY + 20) && (*PlayerY <= (sen + 1) * 20))
					{
						*scrollX = *OldkeyX;
						*PlayerY = *OldkeyY;
						*jumppower = 0;
					}
				}

			}
		}
	}
	////1-3
	if (*stage == 13)
	{
		for (int len = 0; len < MAPYOKO; len++)
		{

			for (int sen = 0; sen < MAPTATE; sen++)
			{
				if (MAP1_3[len][sen] == 1)
				{
					if ((len * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (len + 1) * 20 + *scrollX) && (sen * 20 <= *PlayerY + 20) && (*PlayerY <= (sen + 1) * 20))
					{
						//文字ブロックに当たったら前の座標に戻る
						*scrollX = *OldkeyX;
						*PlayerY = *OldkeyY;
						*jumppower = 0;
					}
				}
				if (MAP1_3[len][sen] == 30)
				{
					if ((len * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (len + 1) * 20 + *scrollX) && (sen * 20 <= *PlayerY + 20) && (*PlayerY <= (sen + 1) * 20))
					{
						*scrollX = *OldkeyX;
						*PlayerY = *OldkeyY;
						*jumppower = 0;
					}
				}

			}
		}
	}
	////1-4
	if (*stage == 14)
	{
		for (int len = 0; len < MAPYOKO; len++)
		{

			for (int sen = 0; sen < MAPTATE; sen++)
			{
				if (MAP1_4[len][sen] == 1)
				{
					if ((len * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (len + 1) * 20 + *scrollX) && (sen * 20 <= *PlayerY + 20) && (*PlayerY <= (sen + 1) * 20))
					{
						//文字ブロックに当たったら前の座標に戻る
						*scrollX = *OldkeyX;
						*PlayerY = *OldkeyY;
						*jumppower = 0;
					}
				}
				if (MAP1_4[len][sen] == 30)
				{
					if ((len * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (len + 1) * 20 + *scrollX) && (sen * 20 <= *PlayerY + 20) && (*PlayerY <= (sen + 1) * 20))
					{
						*scrollX = *OldkeyX;
						*PlayerY = *OldkeyY;
						*jumppower = 0;
					}
				}

			}
		}
	}
	////オプションボタン///////////////////////////////////////////////////////
	for (int len = 0; len < MAPYOKO; len++)
	{

		for (int sen = 0; sen < MAPTATE; sen++)
		{
			if (gamescreen[len][sen] == 10)
			{
				
				if ((len * 20 <= MouseXPos) && (MouseXPos <= (len + 1) * 20) && (sen * 20 <= MouseYPos) && (MouseYPos <= (sen + 1) * 20))
				{
					if ((GetMouseInput() & MOUSE_INPUT_LEFT) == 1)
					{

						*myreturn = STAGESERECT;

					}
				}
			}
		}
	}
	char a = 'z';
	//弾に文字を入れる
	for (int sen = 0; sen < 5; sen++)
	{
		if (mi[0].tama[sen][0] == a)
		{
			char ranmoji[93];
			int random = 0;
			int randam = 0;
			switch (*stage)
			{
			case 0:
				random = 3;
				{
					char ranmoji11[3] = { "け" };
					for (int men = 0; men < random; men++)
					{
						ranmoji[men] = ranmoji11[men];
					}
				}
				break;
			case  11:
				random = 9;
				{
					char ranmoji11[9] = { "けんばく" };
					for (int men = 0; men < random; men++)
					{
						ranmoji[men] = ranmoji11[men];
					}
				}
				break;
			case  12:
				random = 13;
				{
					char ranmoji12[13] = { "たてゆみばく" };
					for (int men = 0; men < random; men++)
					{
						ranmoji[men] = ranmoji12[men];
					}
				}
				break;
			case  13:
				random = 11;
				{
					char ranmoji13[11] = { "けんばくぐ" };
					for (int men = 0; men < random; men++)
					{
						ranmoji[men] = ranmoji13[men];
					}
				}
				break;
			case   14:
				random = 19;
				{
					char ranmoji14[19] = { "けんたてばくぐゆみ" };
					for (int men = 0; men < random; men++)
					{
						ranmoji[men] = ranmoji14[men];
					}
				}
				break;
			}

			randam = GetRand(random - 2);

			mi[0].tama[sen][2] = ranmoji[random - 1];
			if (!(randam == 0))
			{
				if (randam % 2 == 1)
				{
					randam--;
				}
			}

			for (int men = 0; men < 2; men++)
			{
				mi[0].tama[sen][men] = ranmoji[randam + men];
			}

		}


	}

	//文字移動
	for (int len = 0; len < 5; len++)
	{
		if (!(mi[0].tamaX[len] == -1))
		{
			//弾が上に行く場合
			if (mi[0].direction[len] == UP)
			{
				--mi[0].tamaY[len];
				//画面端にいった場合、弾を初期値に戻す
				if (mi[0].tamaY[len] == 0)
				{
					mi[0].tamaX[len] = -1;
					mi[0].tama[len][0] = a;
					mi[0].direction[len] = -2;
				}
			}
			//弾が右に行く場合
			if (mi[0].direction[len] == RIGHT)
			{
				++mi[0].tamaX[len];
				//画面端にいった場合、弾を初期値に戻す
				if (mi[0].tamaX[len] == 640)
				{
					mi[0].tamaX[len] = -1;
					mi[0].tama[len][0] = a;
					mi[0].direction[len] = -2;
				}
			}
			//弾が下に行く場合
			if (mi[0].direction[len] == DOWN)
			{
				++mi[0].tamaY[len];
				//画面端にいった場合、弾を初期値に戻す
				if (mi[0].tamaY[len] == 480)
				{
					mi[0].tamaX[len] = -1;
					mi[0].tama[len][0] = a;
					mi[0].direction[len] = -2;
				}
			}
			//弾が左に行く場合
			if (mi[0].direction[len] == LEFT)
			{
				--mi[0].tamaX[len];
				//画面端にいった場合、弾を初期値に戻す
				if (mi[0].tamaX[len] == 0)
				{
					mi[0].tamaX[len] = -1;
					mi[0].tama[len][0] = a;
					mi[0].direction[len] = -2;
				}
			}

		}
	}

	//文字を撃つ
	int owari = 0;
	//時間習得
	DATEDATA Date;
	GetDateTime(&Date);
	//前に撃った時から時間が経っているかどうか
	if ((!(*ballettime == Date.Sec))&&(sere->rotate == 0)&&(shoot == 1))
	{
		//今の時間を入れる
		*ballettime = Date.Sec;


		
			for (int len = 0; len < 5 && owari == 0; len++)
			{
				if (mi[0].tamaX[len] == -1)
				{
					//弾を自分の座標に
					mi[0].tamaX[len] = *PlayerX;
					mi[0].tamaY[len] = *PlayerY;
					mi[0].tamascrollX[len] = *scrollX;
					if (mi[0].direction[len] < -1)
					{
						//弾を発射する向きを入れる
						mi[0].direction[len] = *mydirection;
					}
					len = 5;
					char a[3];

					for (int men = 0; men < 3; men++)
					{
						//弾の順番入れ替え
						a[men] = mi[0].tama[0][men];

					}
					int b = mi[0].tamaX[0];
					int c = mi[0].tamaY[0];
					int d = mi[0].direction[0];
					int e = mi[0].tamascrollX[0];
					for (int sen = 0; sen < 4; sen++)
					{
						for (int men = 0; men < 3; men++)
						{
							mi[0].tama[sen][men] = mi[0].tama[sen + 1][men];
						}
						mi[0].tamaX[sen] = mi[0].tamaX[sen + 1];
						mi[0].tamaY[sen] = mi[0].tamaY[sen + 1];
						mi[0].direction[sen] = mi[0].direction[sen + 1];
						mi[0].tamascrollX[sen] = mi[0].tamascrollX[sen + 1];
					}
					for (int men = 0; men < 3; men++)
					{
						mi[0].tama[4][men] = a[men];
					}
					mi[0].tamaX[4] = b;
					mi[0].tamaY[4] = c;
					mi[0].direction[4] = d;
					mi[0].tamascrollX[4] = e;
					owari = 1;
				}

			}
		
	}
	for (int len = 0; len < 5; len++)
	{
		if (!(mi[0].tamaX[len] < 0))
		{
			if (!(mi[0].tamascrollX[len] == *scrollX))
			{
				int o = 0;
				o = mi[0].tamascrollX[len] - *scrollX;

				mi[0].tamaX[len] -= o;
				mi[0].tamascrollX[len] = *scrollX;
			}
		}
	}
	sen = 0;
	for (int hen = 0; hen * 24 < *brox; hen++)
	{
		for (sen = 0; hen * 24 + sen < *brox&&sen < 24; sen++)
		{

			//文字弾当たり判定
			for (int len = 0; len < 5; len++)
			{
				if (!(mi[0].tamaX[len] < 0))
				{
					if ((mi[hen].mojisuutate[sen] * 20 + *scrollX <= mi[0].tamaX[len] + 20) && (mi[0].tamaX[len] <= (mi[hen].mojisuutate[sen] + 1) * 20 + *scrollX) && (mi[hen].mojisuuyoko[sen] * 20 <= mi[0].tamaY[len] + 20) && (mi[0].tamaY[len] <= (mi[hen].mojisuuyoko[sen] + 1) * 20) && (mi[hen].Appearance[sen] == 0))
					{
						//右当たり判定
						if (((mi[hen].mojisuutate[sen] - 1) * 20 + *scrollX <= mi[0].tamaX[len] + 20) && (mi[0].tamaX[len] <= (mi[hen].mojisuutate[sen]) * 20 + *scrollX) && (mi[hen].mojisuuyoko[sen] * 20 <= mi[0].tamaY[len] + 20) && (mi[0].tamaY[len] <= (mi[hen].mojisuuyoko[sen] + 1) * 20))
						{

							*brox = *brox + 1;
							int ken = 0;
							int owari = 0;
							for (int gen = 0; gen * 24 < *brox&&owari == 0; gen++)
							{
								for (ken = 0; gen * 24 + ken < *brox&&ken < 24 && owari == 0; ken++)
								{
									if (mi[gen].mojisuutate[ken] < -1)
									{
										mi[gen].mojisuutate[ken] = (mi[hen].mojisuutate[sen] - 1);
										mi[gen].mojisuuyoko[ken] = mi[hen].mojisuuyoko[sen];
										mi[gen].Appearance[ken] = 0;
										for (int men = 0; men < 3; men++)
										{
											mi[mi[gen].mojisuutate[ken]].moji[mi[gen].mojisuuyoko[ken]][men] = mi[0].tama[len][men];
										}
										owari = 1;
										mi[0].tama[len][0] = a;

									}

								}
								ken = 0;
							}


							mi[0].tamaY[len] = -1;
							mi[0].tamaX[len] = -1;
							mi[0].direction[len] = -2;

						}

						//左当たり判定
						if (((mi[hen].mojisuutate[sen] + 1) * 20 + *scrollX <= mi[0].tamaX[len] + 20) && (mi[0].tamaX[len] <= (mi[hen].mojisuutate[sen] + 2) * 20 + *scrollX) && (mi[hen].mojisuuyoko[sen] * 20 <= mi[0].tamaY[len] + 20) && (mi[0].tamaY[len] <= (mi[hen].mojisuuyoko[sen] + 1) * 20))
						{

							*brox = *brox + 1;
							int ken = 0;
							int owari = 0;
							for (int gen = 0; gen * 24 < *brox&&owari == 0; gen++)
							{
								for (ken = 0; gen * 24 + ken < *brox&&ken < 24 && owari == 0; ken++)
								{
									if (mi[gen].mojisuutate[ken] < -1)
									{
										mi[gen].mojisuutate[ken] = (mi[hen].mojisuutate[sen] + 1);
										mi[gen].mojisuuyoko[ken] = mi[hen].mojisuuyoko[sen];
										mi[gen].Appearance[ken] = 0;
										for (int men = 0; men < 3; men++)
										{
											mi[mi[gen].mojisuutate[ken]].moji[mi[gen].mojisuuyoko[ken]][men] = mi[0].tama[len][men];
										}
										owari = 1;
										mi[0].tama[len][0] = a;
									}

								}
								ken = 0;
							}


							mi[0].tamaY[len] = -1;
							mi[0].tamaX[len] = -1;
							mi[0].direction[len] = -2;

						}






					}
				}
			}

		}
	}

	///////////////////////////チュートリアル弾当たり判定///////////////////////////////


	for (int gon = 0; gon < MAPYOKO; gon++)
	{

		for (int sen = 0; sen < MAPTATE; sen++)
		{
			if (tutorial[gon][sen] == 30)
			{


				//文字弾当たり判定
				for (int len = 0; len < 5; len++)
				{
					if (!(mi[0].tamaX[len] < 0))
					{

						if ((gon * 20 + *scrollX <= mi[0].tamaX[len] + 20) && (mi[0].tamaX[len] <= (gon + 1) * 20 + *scrollX) && (sen * 20 <= mi[0].tamaY[len] + 20) && (mi[0].tamaY[len] <= (sen + 1) * 20))
						{
							//右当たり判定
							if (((gon - 1) * 20 + *scrollX <= mi[0].tamaX[len] + 20) && (mi[0].tamaX[len] <= gon * 20 + *scrollX) && (sen * 20 <= mi[0].tamaY[len] + 20) && (mi[0].tamaY[len] <= (sen + 1) * 20))
							{


								if (!(tutorial[gon - 1][sen] == 30))
								{
									tutorial[gon - 1][sen] = 30;
									for (int men = 0; men < 3; men++)
									{
										maji[gon - 1].letter[sen][men] = mi[0].tama[len][men];
									}
									mi[0].tama[len][0] = a;

								}






								mi[0].tamaY[len] = -1;
								mi[0].tamaX[len] = -1;
								mi[0].direction[len] = -2;

							}

							//左当たり判定
							if (((gon + 1) * 20 + *scrollX <= mi[0].tamaX[len] + 20) && (mi[0].tamaX[len] <= (gon + 2) * 20 + *scrollX) && (sen * 20 <= mi[0].tamaY[len] + 20) && (mi[0].tamaY[len] <= (sen + 1) * 20))
							{
								if (!(tutorial[gon + 1][sen] == 30))
								{
									tutorial[gon + 1][sen] = 30;

									for (int men = 0; men < 3; men++)
									{
										maji[gon + 1].letter[sen][men] = mi[0].tama[len][men];
									}
									mi[0].tama[len][0] = a;

								}

								mi[0].tamaY[len] = -1;
								mi[0].tamaX[len] = -1;
								mi[0].direction[len] = -2;

							}






						}
					}
				}
			}
		}
	}

	
	








	//弾表示
	for (int len = 0; len < 5; len++)
	{
		if (!(mi[0].tamaX[len] == -1))
		{
			
			char a[5][3];
			char b[5][3];
			//"たて",
			//"ゆみ",
			//"ばくだん",
			//"けん",
			for (int men = 0; men < 5; men++)
			{
				a[men][2] = mi[men].code[4];
				b[men][2] = mi[men].code[4];
				for (int n = 0; n < 2; n++)
				{
					a[men][n] = mi[men].code[n];
					b[men][n] = mi[men].code[n + 2];
				}
			}
			//コード0と同じ文字だった場合
			if (((mi[0].tama[len][0] == a[0][0]) && (mi[0].tama[len][1] == a[0][1]) && (mi[0].tama[len][2] == a[0][2])) || ((mi[0].tama[len][0] == b[0][0]) && (mi[0].tama[len][1] == b[0][1]) && (mi[0].tama[len][2] == b[0][2])))
			{
				DrawFormatString(mi[0].tamaX[len] + 4, mi[0].tamaY[len], GetColor(0, 0, 255), "%s", mi[0].tama[len]);
			}
			//コード1と同じ文字だった場合
			else if (((mi[0].tama[len][0] == a[1][0]) && (mi[0].tama[len][1] == a[1][1]) && (mi[0].tama[len][2] == a[1][2])) || ((mi[0].tama[len][0] == b[1][0]) && (mi[0].tama[len][1] == b[1][1]) && (mi[0].tama[len][2] == b[1][2])))
			{
				DrawFormatString(mi[0].tamaX[len] + 4, mi[0].tamaY[len], GetColor(0, 255, 0), "%s", mi[0].tama[len]);
			}
			//コード2と同じ文字だった場合
			else if (((mi[0].tama[len][0] == a[2][0]) && (mi[0].tama[len][1] == a[2][1]) && (mi[0].tama[len][2] == a[2][2])) || ((mi[0].tama[len][0] == b[2][0]) && (mi[0].tama[len][1] == b[2][1]) && (mi[0].tama[len][2] == b[2][2])))
			{
				DrawFormatString(mi[0].tamaX[len] + 4, mi[0].tamaY[len], GetColor(255, 0, 255), "%s", mi[0].tama[len]);
			}
			//コード3と同じ文字だった場合
			else if (((mi[0].tama[len][0] == a[3][0]) && (mi[0].tama[len][1] == a[3][1]) && (mi[0].tama[len][2] == a[3][2])) || ((mi[0].tama[len][0] == b[3][0]) && (mi[0].tama[len][1] == b[3][1]) && (mi[0].tama[len][2] == b[3][2])))
			{
				DrawFormatString(mi[0].tamaX[len] + 4, mi[0].tamaY[len], GetColor(255, 0,0), "%s", mi[0].tama[len]);
			}
			//当てはまらなかった場合
			else
			{
				DrawFormatString(mi[0].tamaX[len] + 4, mi[0].tamaY[len], GetColor(255, 255, 255), "%s", mi[0].tama[len]);
			}
		}
	}







	//アイテム
	for (int men = 0; men < 32; men++)
	{
		if (!(mi[men].aitemX < -1))
		{
			switch (mi[men].weapon)
			{
			case  0://たて
				if ((mi[men].aitemX + *scrollX == *OldkeyX) && (mi[men].aitemY == *OldkeyY))
				{
					mi[men].aitemX = *PlayerX;
					mi[men].aitemY = *PlayerY;
				}
				if (((mi[men].aitemX) * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (mi[men].aitemX + 1) * 20 + *scrollX) && ((mi[men].aitemY) * 20 <= *PlayerY + 20) && (*PlayerY <= (mi[men].aitemY + 1) * 20))
				{
					mi[men].have = 1;
					++mi[0].Playerlife;
					mi[men].durable = 1;
					mi[men].aitemX = *PlayerX;
					mi[men].aitemY = *PlayerY;
				}

				//DrawBox(mi[men].aitemX * 20, mi[men].aitemY * 20, (mi[men].aitemX + 1) * 20, mi[men].aitemY * 20 + 5, GetColor(255, 255, 0), TRUE);
				//DrawExtendGraph(mi[men].aitemX * 20, mi[men].aitemY * 20, (mi[men].aitemX + 1) * 20, (mi[men].aitemY + 1) * 20, im->gh[18], TRUE);
				DrawRotaGraph(mi[men].aitemX * 20 + *scrollX, mi[men].aitemY * 20, 0.2f, 0, im->gh[18], TRUE);
				//DrawExtendGraph(mi[men].aitemX * 20 + *scrollX, mi[men].aitemY * 20, (mi[men].aitemX + 1) * 20 + *scrollX, (mi[men].aitemY + 1) * 20, im->gh[18], TRUE);
				break;
			case 1://ゆみ
				if ((mi[men].aitemX + *scrollX == *OldkeyX) && (mi[men].aitemY == *OldkeyY))
				{
					mi[men].aitemX = *PlayerX;
					mi[men].aitemY = *PlayerY;
				}
				if (((mi[men].aitemX) * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (mi[men].aitemX + 1) * 20 + *scrollX) && ((mi[men].aitemY) * 20 <= *PlayerY + 20) && (*PlayerY <= (mi[men].aitemY + 1) * 20))
				{
					mi[men].have = 1;
					mi[men].durable = 3;
					mi[men].aitemX = *PlayerX;
					mi[men].aitemY = *PlayerY;
				}
				//前に撃った時から時間が経っているかどうか
				if ((!(*ballettime == Date.Sec)) && (sere->rotate == 2) && (shoot == 1))
				{
					//今の時間を入れる
					*ballettime = Date.Sec;


					owari = 0;

					for (int n = 1; n < 32 && owari == 0; n++)
					{
						if (mi[n].tamaX[0] < -1)
						{
							//弾を自分の座標に
							mi[n].tamaX[0] = *PlayerX;
							mi[n].tamaY[0] = *PlayerY;
							mi[n].tamascrollX[0] = *scrollX;
							if (mi[n].direction[0] < -1)
							{
								//弾を発射する向きを入れる
								mi[n].direction[0] = *mydirection;
							}
							--mi[men].durable;
							owari = 1;
							mi[n].yumi = 1;

						}
					}
					
				}
				DrawRotaGraph(mi[men].aitemX * 20 + *scrollX, mi[men].aitemY * 20, 0.1f, 0, im->gh[21], TRUE);

				break;
			case 2://ばく
				if ((mi[men].aitemX + *scrollX == *OldkeyX) && (mi[men].aitemY == *OldkeyY) && (mi[men].Waitingtime < -1))
				{
					mi[men].aitemX = *PlayerX;
					mi[men].aitemY = *PlayerY;
				}
				if (((mi[men].aitemX) * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (mi[men].aitemX + 1) * 20 + *scrollX) && ((mi[men].aitemY) * 20 <= *PlayerY + 20) && (*PlayerY <= (mi[men].aitemY + 1) * 20) && (mi[men].Waitingtime < -1))
				{
					mi[men].have = 1;
					mi[men].durable = 1;
					mi[men].aitemX = *PlayerX;
					mi[men].aitemY = *PlayerY;
				}
				//前に撃った時から時間が経っているかどうか
				if (((!(*ballettime == Date.Sec)) && (sere->rotate == 3) && (shoot == 1)&&(mi[men].have == 1))||(mi[men].Waitingtime > 0))
				{
				
					//今の時間を入れる
					*ballettime = Date.Sec;
					if (mi[men].Waitingtime < -1)
					{
						mi[men].Waitingtime = 200;
						mi[men].aitemX = *PlayerX;
						mi[men].aitemY = *PlayerY;
						mi[men].tamascrollX[10] = *scrollX;
					}
					else
					{
						--mi[men].Waitingtime;
					}
					//爆弾画面スクロール処理
						
					if (!(mi[men].tamascrollX[10] == *scrollX))
					{
						int o = 0;
						o = mi[men].tamascrollX[10] - *scrollX;

						mi[men].aitemX -= o;
						mi[men].tamascrollX[10] = *scrollX;


					}
						
					
					DrawRotaGraph(mi[men].aitemX, mi[men].aitemY, 0.2f, 0, im->gh[25], TRUE);
					//DrawBox(mi[men].aitemX + *scrollX, mi[men].aitemY, (mi[men].aitemX + 20) + *scrollX, mi[men].aitemY + 20, GetColor(255, 255, 255), TRUE);
					//爆発
					if ((mi[men].Waitingtime  <= 3)&&(mi[men].Waitingtime >= 0))
					{
						DrawExtendGraph(mi[men].aitemX + 50, mi[men].aitemY + 50, mi[men].aitemX - 50, mi[men].aitemY - 50, im->gh[27], TRUE);
						--mi[men].durable;
						//当たった文字ブロックは初期化
						for (int hen = 0; hen * 24 < *brox; hen++)
						{
							for (sen = 0; hen * 24 + sen < *brox&&sen < 24; sen++)
							{
								if ((mi[hen].mojisuutate[sen] * 20 + *scrollX <= mi[men].aitemX + 50) && (mi[men].aitemX - 50 <= (mi[hen].mojisuutate[sen] + 1) * 20 + *scrollX) && (mi[hen].mojisuuyoko[sen] * 20 <= mi[men].aitemY + 50) && (mi[men].aitemY - 50 <= (mi[hen].mojisuuyoko[sen] + 1) * 20))
								{
									if (mi[hen].Appearance[sen] == 0)
									{
										mi[hen].mojisuutate[sen] = -2;
										mi[hen].mojisuuyoko[sen] = -2;
										--mi[men].durable;
										mi[hen].Appearance[sen] = -1;
									}
								}
							}
						}
						//当たった敵にダメージを
						for (int n = 0; n < 32; n++)
						{
							if (!(en[n].enemyX < 0))
							{
								if ((en[n].enemyX * 20 + *scrollX <= mi[men].aitemX + 50) && (mi[men].aitemX - 50 <= (en[n].enemyX + 1) * 20 + *scrollX) && (en[n].enemyY * 20 <= mi[men].aitemY + 50) && (mi[men].aitemY - 50 <= (en[n].enemyY + 1) * 20) && (en[n].enemyinvincible == 0))
								{
									if (en[n].enemyLife <= 0)
									{
										//敵が中ボス以上ならゴールを出現
										if (en[n].enemytype > 1)
										{
											seen->goalappearanceX = en[n].enemyX * 20;
											seen->goalappearanceY = en[n].enemyY * 20;
										}
										en[n].enemytype = -1;
										en[n].enemyX = -1;
										en[n].enemyY = -1;
										en[n].Widthofaction = -1;
										en[n].oldenemyX = -1;
										en[n].oldenemyY = -1;
									}
									else
									{

										--en[n].enemyLife;
										//無敵状態へ
										en[n].enemyinvincible = 1;
										en[n].enemyinvincibletime = 10;
									}
									--mi[men].durable;
								}
							}
						}
					}
				}
				if (mi[men].Waitingtime < -1)
				{
					DrawRotaGraph(mi[men].aitemX * 20 + *scrollX, mi[men].aitemY * 20, 0.2f, 0, im->gh[26], TRUE);
				}
				break;
			case 3://けん
				if ((mi[men].aitemX + *scrollX == *OldkeyX) && (mi[men].aitemY == *OldkeyY))
				{
					mi[men].aitemX = *PlayerX;
					mi[men].aitemY = *PlayerY;
				}
				if (((mi[men].aitemX) * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (mi[men].aitemX + 1) * 20 + *scrollX) && ((mi[men].aitemY) * 20 <= *PlayerY + 20) && (*PlayerY <= (mi[men].aitemY + 1) * 20))
				{
					mi[men].have = 1;
					mi[men].aitemX = *PlayerX;
					mi[men].aitemY = *PlayerY;
				}
				if ((mi[men].have == 1) && (shoot == 1) && (sere->rotate == 4))
				{

					//右に攻撃
					if (*mydirection == RIGHT)
					{
						//DrawBox(*PlayerX + 20, *PlayerY, *PlayerX + 40, *PlayerY + 20, GetColor(255, 255, 0), TRUE);
						//DrawExtendGraph(*PlayerX + 20, *PlayerY, *PlayerX + 40, *PlayerY + 20, im->gh[29], TRUE);
						DrawRotaGraph(*PlayerX+20 + 20, *PlayerY+10, 0.1f,0 , im->gh[29], TRUE);
					}
					//左に攻撃
					if (*mydirection == LEFT)
					{
						//DrawBox(*PlayerX - 20, *PlayerY, *PlayerX, *PlayerY + 20, GetColor(255, 255, 0), TRUE);
						//DrawExtendGraph(*PlayerX - 20, *PlayerY, *PlayerX, *PlayerY + 20, im->gh[30], TRUE);
						DrawRotaGraph(*PlayerX-20, *PlayerY+10, 0.1f, 0, im->gh[30], TRUE);
					}
					//アイテム_剣当たり判定
					int sen = 0;
					for (int hen = 0; hen * 24 < *brox; hen++)
					{
						for (sen = 0; hen * 24 + sen < *brox&&sen < 24; sen++)
						{
							if (*mydirection == RIGHT)
							{
								if ((mi[hen].mojisuutate[sen] * 20 + *scrollX <= *PlayerX + 40) && (*PlayerX + 20 <= (mi[hen].mojisuutate[sen] + 1) * 20 + *scrollX) && (mi[hen].mojisuuyoko[sen] * 20 <= *PlayerY + 20) && (*PlayerY <= (mi[hen].mojisuuyoko[sen] + 1) * 20))
								{
									if (mi[hen].Appearance[sen] == 0)
									{
										mi[hen].mojisuutate[sen] = -2;
										mi[hen].mojisuuyoko[sen] = -2;
										--mi[men].durable;
										mi[hen].Appearance[sen] = -1;
									}
								}
								for (int n = 0; n < 32; n++)
								{
									if (!(en[n].enemyX < 0))
									{
										if ((en[n].enemyX * 20 + *scrollX <= *PlayerX + 40) && (*PlayerX + 20 <= (en[n].enemyX + 1) * 20 + *scrollX) && (en[n].enemyY * 20 <= *PlayerY + 20) && (*PlayerY <= (en[n].enemyY + 1) * 20) && (en[n].enemyinvincible == 0))
										{
											if (en[n].enemyLife <= 0)
											{
												//敵が中ボス以上ならゴールを出現
												if (en[n].enemytype > 1)
												{
													seen->goalappearanceX = en[n].enemyX * 20;
													seen->goalappearanceY = en[n].enemyY * 20;
												}
												en[n].enemytype = -1;
												en[n].enemyX = -1;
												en[n].enemyY = -1;
												en[n].Widthofaction = -1;
												en[n].oldenemyX = -1;
												en[n].oldenemyY = -1;
											}
											else
											{

												--en[n].enemyLife;
												//無敵状態へ
												en[n].enemyinvincible = 1;
												en[n].enemyinvincibletime = 10;
											}
											--mi[men].durable;
										}
									}
								}
							}
							if (*mydirection == LEFT)
							{
								if ((mi[hen].mojisuutate[sen] * 20 + *scrollX <= *PlayerX) && (*PlayerX - 20 <= (mi[hen].mojisuutate[sen] + 1) * 20 + *scrollX) && (mi[hen].mojisuuyoko[sen] * 20 <= *PlayerY + 20) && (*PlayerY <= (mi[hen].mojisuuyoko[sen] + 1) * 20))
								{
									if (mi[hen].Appearance[sen] == 0)
									{
										mi[hen].mojisuutate[sen] = -2;
										mi[hen].mojisuuyoko[sen] = -2;
										--mi[men].durable;
										mi[hen].Appearance[sen] = -1;
									}
								}
								for (int n = 0; n < 32; n++)
								{
									if (!(en[n].enemyX < 0))
									{
										if ((en[n].enemyX * 20 + *scrollX <= *PlayerX) && (*PlayerX - 20 <= (en[n].enemyX + 1) * 20 + *scrollX) && (en[n].enemyY * 20 <= *PlayerY + 20) && (*PlayerY <= (en[n].enemyY + 1) * 20) && (en[n].enemyinvincible == 0))
										{
											if (en[n].enemyLife <= 0)
											{
												//敵が中ボス以上ならゴールを出現
												if (en[n].enemytype > 1)
												{
													seen->goalappearanceX = en[n].enemyX * 20;
													seen->goalappearanceY = en[n].enemyY * 20;
												}
												en[n].enemytype = -1;
												en[n].enemyX = -1;
												en[n].enemyY = -1;
												en[n].Widthofaction = -1;
												en[n].oldenemyX = -1;
												en[n].oldenemyY = -1;
											}
											else
											{

												--en[n].enemyLife;
												//無敵状態
												en[n].enemyinvincible = 1;
												en[n].enemyinvincibletime = 10;
											}
											--mi[men].durable;
										}
									}
								}
							}
						}
					}
					//チュートリアル/////////////////////////////////////////////////
					if (*mydirection == RIGHT)
					{
						for (int n = 0; n < 32; n++)
						{
							if (!(en[n].enemyX < 0))
							{
								if ((en[n].enemyX * 20 + *scrollX <= *PlayerX + 40) && (*PlayerX + 20 <= (en[n].enemyX + 1) * 20 + *scrollX) && (en[n].enemyY * 20 <= *PlayerY + 20) && (*PlayerY <= (en[n].enemyY + 1) * 20) && (en[n].enemyinvincible == 0))
								{
									if (en[n].enemyLife <= 0)
									{
										//敵が中ボス以上ならゴールを出現
										if (en[n].enemytype > 1)
										{
											seen->goalappearanceX = en[n].enemyX * 20;
											seen->goalappearanceY = en[n].enemyY * 20;
										}
										en[n].enemytype = -1;
										en[n].enemyX = -1;
										en[n].enemyY = -1;
										en[n].Widthofaction = -1;
										en[n].oldenemyX = -1;
										en[n].oldenemyY = -1;
									}
									else
									{

										--en[n].enemyLife;
										//無敵状態へ
										en[n].enemyinvincible = 1;
										en[n].enemyinvincibletime = 10;
									}
									--mi[men].durable;

								}
							}
						}
					}
					if (*mydirection == LEFT)
					{
						for (int n = 0; n < 32; n++)
						{
							if (!(en[n].enemyX < 0))
							{
								if ((en[n].enemyX * 20 + *scrollX <= *PlayerX) && (*PlayerX - 20 <= (en[n].enemyX + 1) * 20 + *scrollX) && (en[n].enemyY * 20 <= *PlayerY + 20) && (*PlayerY <= (en[n].enemyY + 1) * 20) && (en[n].enemyinvincible == 0))
								{

									if (en[n].enemyLife <= 0)
									{
										//敵が中ボス以上ならゴールを出現
										if (en[n].enemytype > 1)
										{
											seen->goalappearanceX = en[n].enemyX * 20;
											seen->goalappearanceY = en[n].enemyY * 20;
										}
										en[n].enemytype = -1;
										en[n].enemyX = -1;
										en[n].enemyY = -1;
										en[n].Widthofaction = -1;
										en[n].oldenemyX = -1;
										en[n].oldenemyY = -1;
									}
									else
									{

										--en[n].enemyLife;
										//無敵状態へ
										en[n].enemyinvincible = 1;
										en[n].enemyinvincibletime = 10;
									}
									--mi[men].durable;
								}
							}
						}
					}

				}

				//////////////////////////////////////////////////
				{

					DrawExtendGraph(mi[men].aitemX * 20 + *scrollX, mi[men].aitemY * 20, (mi[men].aitemX + 1) * 20 + *scrollX, (mi[men].aitemY + 1) * 20, im->gh[0], TRUE);
					//DrawBox(mi[men].aitemX * 20 + *scrollX, mi[men].aitemY * 20, (mi[men].aitemX + 1) * 20 + *scrollX, (mi[men].aitemY + 1) * 20, GetColor(255, 255, 2), TRUE);
				}
				break;
			
			}



		}
	}


	//弓矢移動
	for (int len = 1; len < 32; len++)
	{
		if (mi[len].yumi == 1)
		{
			//アイテム_弓矢当たり判定
			int sen = 0;
			for (int n = 1; n < 32; n++)
			{
				if (mi[n].tamaX[0] > -1)
				{
					for (int hen = 0; hen * 24 < *brox; hen++)
					{
						for (sen = 0; hen * 24 + sen < *brox&&sen < 24; sen++)
						{
							//文字ブロック当たり判定
							if ((mi[hen].mojisuutate[sen] * 20 + *scrollX <= mi[n].tamaX[0] + 20) && (mi[n].tamaX[0] <= (mi[hen].mojisuutate[sen] + 1) * 20 + *scrollX) && (mi[hen].mojisuuyoko[sen] * 20 <= mi[n].tamaY[0] + 20) && (mi[n].tamaY[0] <= (mi[hen].mojisuuyoko[sen] + 1) * 20))
							{
								if (mi[hen].Appearance[sen] == 0)
								{
									mi[hen].mojisuutate[sen] = -2;
									mi[hen].mojisuuyoko[sen] = -2;
									mi[len].yumi = -2;
									mi[hen].Appearance[sen] = -1;
								}
							}
							//敵当たり判定
							for (int n = 0; n < 32; n++)
							{
								if (!(en[n].enemyX < 0))
								{
									if ((en[n].enemyX * 20 + *scrollX <= mi[n].tamaX[0] + 20) && (mi[n].tamaX[0] <= (en[n].enemyX + 1) * 20 + *scrollX) && (en[n].enemyY * 20 <= mi[n].tamaY[0] + 20) && (mi[n].tamaY[0] <= (en[n].enemyY + 1) * 20) && (en[n].enemyinvincible == 0))
									{
										if (en[n].enemyLife <= 0)
										{
											//敵が中ボス以上ならゴールを出現
											if (en[n].enemytype > 1)
											{
												seen->goalappearanceX = en[n].enemyX * 20;
												seen->goalappearanceY = en[n].enemyY * 20;
											}
											en[n].enemytype = -1;
											en[n].enemyX = -1;
											en[n].enemyY = -1;
											en[n].Widthofaction = -1;
											en[n].oldenemyX = -1;
											en[n].oldenemyY = -1;

										}
										else
										{

											--en[n].enemyLife;
											//無敵状態へ
											en[n].enemyinvincible = 1;
											en[n].enemyinvincibletime = 10;
										}
										--mi[len].yumi = -2;
									}
								}
							}


						}
					}
				}
			}
			//弓矢が右に行く場合
			if (mi[len].direction[0] == RIGHT)
			{
				++mi[len].tamaX[0];
				//画面端にいった場合、弓矢を初期値に戻す
				if (mi[len].tamaX[0] == 640)
				{
					mi[len].tamaX[0] = -1;
					mi[len].direction[0] = -2;
				}
			}

			//弓矢が左に行く場合
			if (mi[len].direction[0] == LEFT)
			{
				--mi[len].tamaX[0];
				//画面端にいった場合、弓矢を初期値に戻す
				if (mi[len].tamaX[0] == 0)
				{
					mi[len].tamaX[0] = -1;
					mi[len].direction[0] = -2;
				}
			}

		}
	}

	//弓矢画面スクロール処理
	for (int len = 1; len < 32; len++)
	{
		if (mi[len].yumi == 1)
		{
			if (!(mi[len].tamascrollX[0] == *scrollX))
			{
				int o = 0;
				o = mi[len].tamascrollX[0] - *scrollX;

				mi[len].tamaX[0] -= o;
				mi[len].tamascrollX[0] = *scrollX;
				

			}
		}
	}
	
	//弓矢表示
	for (int len = 1; len < 32; len++)
	{
		if (mi[len].yumi == 1)
		{
			if (mi[len].direction[0] == RIGHT)
			{
				DrawExtendGraph(mi[len].tamaX[0], mi[len].tamaY[0], mi[len].tamaX[0] + 20, mi[len].tamaY[0] + 20, im->gh[22], TRUE);

			}
			if (mi[len].direction[0] == LEFT)
			{
				
				DrawExtendGraph(mi[len].tamaX[0], mi[len].tamaY[0], mi[len].tamaX[0]+20, mi[len].tamaY[0]+20 , im->gh[23], TRUE);
			}

		}
	}

	//耐久値が0の場合
	for (int men = 0; men < 32; men++)
	{
		if (mi[men].durable == 0)
		{
			mi[men].aitemX = -2;
			mi[men].aitemY = -2;
			mi[men].weapon = -2;
			mi[men].have = -2;
		}
	}
	//耐久値が0の場合は初期値に
	sen = 0;
	for (int hen = 0; hen < 32; hen++)
	{
		if (!(mi[hen].aitemX < -1))
		{
			if (mi[hen].weapon == 0)
			{
				if ((mi[hen].aitemX * 20 <= *PlayerX + 20) && (*PlayerX <= (mi[hen].aitemX + 1) * 20) && (mi[hen].aitemY * 20 <= *PlayerY + 20) && (*PlayerY <= (mi[hen].aitemY) * 20 + 5))
				{
					*PlayerX = *OldkeyX;
					*PlayerY = *OldkeyY;
					*jumppower = 0;

				}
			}

		}
	}

	//文字に乗る
	for (int len = 0; len < 5; len++)
	{
		if ((mi[0].ride == 1) && (*PlayerX <= mi[0].tamaX[len] + 10) && (*PlayerX + 20 >= mi[0].tamaX[len]) && (*PlayerY <= mi[0].tamaY[len] + 10) && (*PlayerY + 20 >= mi[0].tamaY[len]))
		{
			*PlayerX = mi[0].tamaX[len];
			*PlayerY = mi[0].tamaY[len];
		}
	}

	
	for (int len = 0; len < 32; len++)
	{
		mi[len].weaponsuu = 0;
	}
	//持っているアイテム数
	for (int hen = 0; hen < 32; hen++)
	{
		if (mi[hen].have == 1)
		{
			mi[mi[hen].weapon].weaponsuu += mi[hen].durable;
		}
	}

	//今のプレイヤーの座標を入れる
	*OldkeyX = *scrollX;
	*OldkeyY = *PlayerY;
}

//Draw関数
void Draw(MOJI *mi, int *retime, int *brox, int *PlayerX, int *PlayerY, ENEMY *en, int *breaktime, SERECT *sere, int *timersec, int *timermin, int *stage, int *scrollX, int *scrollY, int *shockwave,MAPMOJI *maji,int *myreturn,SCREEN *seen,int *mydirection,IMAGE *im,INFORMATION *infor,MUSIC *mu)
{

	// 中心座標に角度と長さを使用した円の位置を加算する
		// 度数法の角度を弧度法に変換
	float radius = sere->m_Angle * 3.14f / 180.0f;
	// 三角関数を使用し、円の位置を割り出す。
	float add_x = cos(radius) * sere->m_Length;
	float add_y = sin(radius) * sere->m_Length;
	// 結果ででた位置を中心位置に加算し、それを描画位置とする
	sere->m_PosX = sere->m_CenterX + add_x;
	sere->m_PosY = sere->m_CenterY + add_y;
	if (CheckHitKey(KEY_INPUT_UP) == 1)
	{
		sere->m_Angle += 1.0f;
		sere->oldrotate = 1;
	}
	if (CheckHitKey(KEY_INPUT_DOWN) == 1)
	{
		sere->m_Angle -= 1.0f;
		sere->oldrotate = 0;
	}
	if (CheckHitKey(KEY_INPUT_0) == 1)
	{
		sere->rotate = 0;
	}
	if (CheckHitKey(KEY_INPUT_1) == 1)
	{
		sere->rotate = 1;
	}
	if (CheckHitKey(KEY_INPUT_2) == 1)
	{
		sere->rotate = 2;
	}
	if (CheckHitKey(KEY_INPUT_3) == 1)
	{
		sere->rotate = 3;
	}
	if (CheckHitKey(KEY_INPUT_4) == 1)
	{
		sere->rotate = 4;
	}

	if (!(sere->m_Angle % 180 == 0)&&(sere->oldrotate == 1))
	{
		// 角度を変える
		sere->m_Angle += 1.0f;
	}
	if (!(sere->m_Angle % 180 == 0)&&(sere->oldrotate == 0))
	{
		// 角度を変える
		sere->m_Angle -= 1.0f;
	}
	if ((sere->m_Angle % 90 == 0) && (!(sere->m_Angle % 180 == 0))&&(sere->oldrotate == 1))
	{
		++sere->rotate;
	}
	if ((sere->m_Angle % 90 == 0) && (!(sere->m_Angle % 180 == 0))&&(sere->oldrotate == 0))
	{
		--sere->rotate;
	}
	if (sere->rotate == 5)
	{
		sere->rotate = 0;
	}
	if (sere->rotate == -1)
	{
		sere->rotate = 4;
	}
	
	//DrawCircle(enemy.m_PosX, enemy.m_PosY, enemy.m_Radius, GetColor(255, 255, 255));
	//DrawBox(enemy.m_PosX, enemy.m_PosY, enemy.m_PosX + 40, enemy.m_PosY + 30, GetColor(255, 0, 0), TRUE);
	if (sere->m_PosY >= 480)
	{
		//DrawBox(sere->m_PosX - 90, sere->m_PosY - 80, sere->m_PosX + 140, sere->m_PosY + 10, GetColor(255, 0, 0), TRUE);
		//DrawExtendGraph(sere->m_PosX - 90, sere->m_PosY - 80, sere->m_PosX + 140, sere->m_PosY + 10, im->gh[31], TRUE);
		DrawExtendGraph(sere->m_PosX - 250, sere->m_PosY - 150, sere->m_PosX + 230, sere->m_PosY + 120, im->gh[31], TRUE);

	}
	else
	{
		//DrawBox(sere->m_PosX - 90, 400, sere->m_PosX + 140, sere->m_PosY + 10, GetColor(255, 0, 0), TRUE);
		//DrawExtendGraph(sere->m_PosX - 90, 400, sere->m_PosX + 140, sere->m_PosY + 10, im->gh[31], TRUE);
		DrawExtendGraph(sere->m_PosX - 250, 350, sere->m_PosX + 230, sere->m_PosY + 120, im->gh[31], TRUE);

	}
	int fontSize = 25;
	SetFontSize(fontSize);
	if (sere->m_PosY >= 480)
	{
		switch (sere->rotate)
		{
			//文字を打つ
		case  0:
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 60, GetColor(255, 255, 0), "%s", "文字を撃つ");
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "next→");
			for (int len = 0; len < 5; len++)
			{
				char a[5][3];
				char b[5][3];
				//"たて",
				//"ゆみ",
				//"ばくだん",
				//"けん",
				//"こう",
				for (int men = 0; men < 5; men++)
				{
					a[men][2] = mi[men].code[4];
					b[men][2] = mi[men].code[4];
					for (int n = 0; n < 2; n++)
					{
						a[men][n] = mi[men].code[n];
						b[men][n] = mi[men].code[n + 2];
					}
				}
				//コード0と同じ文字だった場合
				if (((mi[0].tama[len][0] == a[0][0]) && (mi[0].tama[len][1] == a[0][1]) && (mi[0].tama[len][2] == a[0][2])) || ((mi[0].tama[len][0] == b[0][0]) && (mi[0].tama[len][1] == b[0][1]) && (mi[0].tama[len][2] == b[0][2])))
				{
					DrawFormatString(sere->m_PosX + len*20, sere->m_PosY - 30, GetColor(0, 0, 255), "%s", mi[0].tama[len]);
				}
				//コード1と同じ文字だった場合
				else if (((mi[0].tama[len][0] == a[1][0]) && (mi[0].tama[len][1] == a[1][1]) && (mi[0].tama[len][2] == a[1][2])) || ((mi[0].tama[len][0] == b[1][0]) && (mi[0].tama[len][1] == b[1][1]) && (mi[0].tama[len][2] == b[1][2])))
				{

					DrawFormatString(sere->m_PosX + len*20, sere->m_PosY - 30, GetColor(0, 255, 0), "%s",mi[0].tama[len]);

				}
				//コード2と同じ文字だった場合
				else if (((mi[0].tama[len][0] == a[2][0]) && (mi[0].tama[len][1] == a[2][1]) && (mi[0].tama[len][2] == a[2][2])) || ((mi[0].tama[len][0] == b[2][0]) && (mi[0].tama[len][1] == b[2][1]) && (mi[0].tama[len][2] == b[2][2])))
				{
		
					DrawFormatString(sere->m_PosX + len*20, sere->m_PosY - 30, GetColor(255, 0, 255), "%s", mi[0].tama[len]);

				}
				//コード3と同じ文字だった場合
				else if (((mi[0].tama[len][0] == a[3][0]) && (mi[0].tama[len][1] == a[3][1]) && (mi[0].tama[len][2] == a[3][2])) || ((mi[0].tama[len][0] == b[3][0]) && (mi[0].tama[len][1] == b[3][1]) && (mi[0].tama[len][2] == b[3][2])))
				{
				
					DrawFormatString(sere->m_PosX + len*20, sere->m_PosY - 30, GetColor(255, 0, 0), "%s", mi[0].tama[len]);

				}
				//当てはまらなかった場合
				else
				{
					DrawFormatString(sere->m_PosX + len*20, sere->m_PosY - 30, GetColor(255, 255, 255), "%s", mi[0].tama[len]);

				}
			}
			break;
			//アイテム1を使う
		case 1:
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 60, GetColor(255, 255, 0), "アイテム%s", mi[0].code);
			if (mi[0].weaponsuu > 0)
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "%d持っています。", mi[0].weaponsuu);
			}
			else
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "持っていません");
			}
			//DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 80, GetColor(255, 255, 0), "%d", sere->rotate);
			break;
		case 2:
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 60, GetColor(255, 255, 0), "アイテム%s", mi[1].code);
			if (mi[1].weaponsuu > 0)
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "%d持っています。", mi[1].weaponsuu);
			}
			else
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "持っていません");
			}
			break;
		case 3:
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 60, GetColor(255, 255, 0), "アイテム%s", mi[2].code);
			if (mi[2].weaponsuu > 0)
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "%d持っています。", mi[2].weaponsuu);
			}
			else
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "持っていません");
			}
			break;
		case 4:
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 60, GetColor(255, 255, 0), "アイテム%s", mi[3].code);
			if (mi[3].weaponsuu > 0)
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "%d持っています。", mi[3].weaponsuu);
			}
			else
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "持っていません");
			}
			break;
		case 5:
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 60, GetColor(255, 255, 0), "アイテム%s", mi[4].code);
			if (mi[4].weaponsuu > 0)
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "%d持っています。", mi[4].weaponsuu);
			}
			else
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "持っていません");
			}
			break;
		};
	}
	fontSize = 18;
	SetFontSize(fontSize);
	sere->m_PosX = sere->m_CenterX - add_x;
	sere->m_PosY = sere->m_CenterY - add_y;
	if (sere->m_PosY >= 480)
	{
		
		DrawExtendGraph(sere->m_PosX -250,sere->m_PosY -150,sere->m_PosX +230,sere->m_PosY +120, im->gh[31], TRUE);
		
	}
	else
	{
		
		DrawExtendGraph(sere->m_PosX - 250, 350, sere->m_PosX + 230, sere->m_PosY + 120, im->gh[31], TRUE);
		
	}
	fontSize = 25;
	SetFontSize(fontSize);
	if (sere->m_PosY >= 480)
	{
		switch (sere->rotate)
		{
			//文字を打つ
		case  0:
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 60, GetColor(255, 255, 0), "%s", "文字を撃つ");
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "next→");
			for (int len = 0; len < 5; len++)
			{
				char a[5][3];
				char b[5][3];
				//"たて",
				//"ゆみ",
				//"ばく",
				//"けん",
				//"つえ",
				for (int men = 0; men < 5; men++)
				{
					a[men][2] = mi[men].code[4];
					b[men][2] = mi[men].code[4];
					for (int n = 0; n < 2; n++)
					{
						a[men][n] = mi[men].code[n];
						b[men][n] = mi[men].code[n + 2];
					}
				}
				//コード0と同じ文字だった場合
				if (((mi[0].tama[len][0] == a[0][0]) && (mi[0].tama[len][1] == a[0][1]) && (mi[0].tama[len][2] == a[0][2])) || ((mi[0].tama[len][0] == b[0][0]) && (mi[0].tama[len][1] == b[0][1]) && (mi[0].tama[len][2] == b[0][2])))
				{
					DrawFormatString(sere->m_PosX  + len*20, sere->m_PosY - 30, GetColor(0,0, 255), "%s", mi[0].tama[len]);
				}
				//コード1と同じ文字だった場合
				else if (((mi[0].tama[len][0] == a[1][0]) && (mi[0].tama[len][1] == a[1][1]) && (mi[0].tama[len][2] == a[1][2])) || ((mi[0].tama[len][0] == b[1][0]) && (mi[0].tama[len][1] == b[1][1]) && (mi[0].tama[len][2] == b[1][2])))
				{

					DrawFormatString(sere->m_PosX + len*20, sere->m_PosY - 30, GetColor(0, 255, 0), "%s", mi[0].tama[len]);

				}
				//コード2と同じ文字だった場合
				else if (((mi[0].tama[len][0] == a[2][0]) && (mi[0].tama[len][1] == a[2][1]) && (mi[0].tama[len][2] == a[2][2])) || ((mi[0].tama[len][0] == b[2][0]) && (mi[0].tama[len][1] == b[2][1]) && (mi[0].tama[len][2] == b[2][2])))
				{

					DrawFormatString(sere->m_PosX + len*20, sere->m_PosY - 30, GetColor(255, 0, 255), "%s", mi[0].tama[len]);

				}
				//コード3と同じ文字だった場合
				else if (((mi[0].tama[len][0] == a[3][0]) && (mi[0].tama[len][1] == a[3][1]) && (mi[0].tama[len][2] == a[3][2])) || ((mi[0].tama[len][0] == b[3][0]) && (mi[0].tama[len][1] == b[3][1]) && (mi[0].tama[len][2] == b[3][2])))
				{

					DrawFormatString(sere->m_PosX + len*20, sere->m_PosY - 30, GetColor(255, 0, 0), "%s", mi[0].tama[len]);

				}
			
				//当てはまらなかった場合
				else
				{
					DrawFormatString(sere->m_PosX +len *20, sere->m_PosY - 30, GetColor(255, 255, 255), "%s", mi[0].tama[len]);

				}
			}
			break;
			//アイテム1を使う
		case 1:
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 60, GetColor(255, 255, 0), "アイテム%s",mi[0].code);
			if (mi[0].weaponsuu > 0)
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "%d持っています。", mi[0].weaponsuu);
			}
			else
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "持っていません");
			}
			
			break;
		case 2:
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 60, GetColor(255, 255, 0), "アイテム%s",mi[1].code);
			if (mi[1].weaponsuu > 0)
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "%d持っています。", mi[1].weaponsuu);
			}
			else
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "持っていません");
			}
			break;
		case 3:
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 60, GetColor(255, 255, 0), "アイテム%s", mi[2].code);
			if (mi[2].weaponsuu > 0)
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "%d持っています。", mi[2].weaponsuu);
			}
			else
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "持っていません");
			}
			break;
		case 4:
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 60, GetColor(255, 255, 0), "アイテム%s", mi[3].code);
			if (mi[3].weaponsuu > 0)
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "%d持っています。", mi[3].weaponsuu);
			}
			else
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "持っていません");
			}
			break;
		case 5:
			DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 60, GetColor(255, 255, 0), "アイテム%s", mi[4].code);
			if (mi[4].weaponsuu > 0)
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "%d持っています。", mi[4].weaponsuu);
			}
			else
			{
				DrawFormatString(sere->m_PosX - 80, sere->m_PosY - 30, GetColor(255, 255, 0), "持っていません");
			}
			break;
		};
	}
	fontSize = 18;
	SetFontSize(fontSize);

	




	if (*breaktime < -1)
	{
		*breaktime = 40;
	}

	//比較関数
	comparison(mi, brox,scrollX,scrollY,maji,stage,en);

	//プレイヤーが文字ブロックに閉じ込められている場合
	if (!(mi[0].frozen < -1))
	{
		DrawBox(*PlayerX, *PlayerY, *PlayerX + 20, *PlayerY + 20, GetColor(0,0, 255), TRUE);

	}
	else if (mi[0].Playerinvincibletime > 0)
	{
		DrawBox(*PlayerX, *PlayerY, *PlayerX + 20, *PlayerY + 20, GetColor(255, 0,0), TRUE);

	}
	else
	{
		//プレイヤー表示
		//DrawBox(*PlayerX, *PlayerY, *PlayerX + 20, *PlayerY + 20, GetColor(255, 255, 255), TRUE);
		if (*mydirection == RIGHT)
		{
			int gh1 = LoadGraph("kyara.png");
			DrawExtendGraph(*PlayerX, *PlayerY, *PlayerX + 20, *PlayerY + 20, im->gh[1], TRUE);
		}
		if (*mydirection == LEFT)
		{
			
			DrawExtendGraph(*PlayerX, *PlayerY, *PlayerX + 20, *PlayerY + 20,im->gh[2], TRUE);
		}
	}

	 
	if (!(*stage == 0))
	{
		//時間習得
		DATEDATA Date;
		GetDateTime(&Date);
		//if (!(*retime == Date.Sec))
		int randam = 0;
		int randam2 = 0;
		//前回から時間が経っているか

		if ((Date.Sec % 5 == 0) && (!(Date.Sec == *retime)))
		{


			*retime = Date.Sec;
			{
				int w = 0;
				int owari = 0;
				for (int q = 0; q * 24; q++)
				{
					for (w = 0; q * 24 + w < *brox&&w < 24; w++)
					{
						if (mi[q].mojisuutate[w] < -1)
						{
							owari = 1;
						}
					}
				}
				if (owari == 0)
				{
					*brox = *brox + 1;
				}
			}
			int sen = 0;

			for (int hen = 0; hen * 24 < *brox; hen++)
			{
				for (sen = 0; hen * 24 + sen < *brox&&sen < 24; sen++)
				{
					if (!(mi[hen].mojisuutate[sen] < -1))
					{
						randam = mi[hen].mojisuutate[sen];
						randam2 = mi[hen].mojisuuyoko[sen];
					}
					else
					{
						randam = GetRand(31);
						randam2 = GetRand(19);
						while (randam2 <= 5)
						{
							randam2 = GetRand(19);
						}
					}

					if (mi[hen].mojisuutate[sen] < -1)
					{
						mi[hen].mojisuutate[sen] = randam;
						mi[hen].mojisuuyoko[sen] = randam2;
						mi[hen].Appearance[sen] = BLINKING;
					}
				}
				sen = 0;
			}

		}

		//ランダム文字ブロック表示
		int  sen = 0;
		for (int hen = 0; hen * 24 < *brox; hen++)
		{
			for (sen = 0; hen * 24 + sen < *brox&&sen < 24; sen++)
			{
				//点滅状態が終わった場合表示
				if (mi[hen].Appearance[sen] == 0)
				{
					
						char a[5][3];
						char b[5][3];
						//"たて",
						//"ゆみ",
						//"ばくだん",
						//"けん",
						//"こう",
						for (int men = 0; men < 5; men++)
						{
							a[men][2] = mi[men].code[4];
							b[men][2] = mi[men].code[4];
							for (int n = 0; n < 2; n++)
							{
								a[men][n] = mi[men].code[n];
								b[men][n] = mi[men].code[n + 2];
							}
						}
						//コード0と同じ文字だった場合
						if (((mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][0] == a[0][0]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][1] == a[0][1]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][2] == a[0][2])) || ((mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][0] == b[0][0]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][1] == b[0][1]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][2] == b[0][2])))
						{
							
								DrawFormatString(20 * mi[hen].mojisuutate[sen] + 2 + *scrollX, 20 * (mi[hen].mojisuuyoko[sen]) + 2, GetColor(0, 0, 255), "%s", mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]]);
								DrawBox(20 * mi[hen].mojisuutate[sen] + *scrollX, 20 * mi[hen].mojisuuyoko[sen], 20 * (mi[hen].mojisuutate[sen] + 1) + *scrollX, 20 * (mi[hen].mojisuuyoko[sen] + 1), GetColor(0, 0, 255), FALSE);
							
							
						}
						//コード1と同じ文字だった場合
						else if (((mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][0] == a[1][0]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][1] == a[1][1]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][2] == a[1][2])) || ((mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][0] == b[1][0]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][1] == b[1][1]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][2] == b[1][2])))
						{
							DrawFormatString(20 * mi[hen].mojisuutate[sen] + 2 + *scrollX, 20 * (mi[hen].mojisuuyoko[sen]) + 2, GetColor(0, 255, 0), "%s", mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]]);
							DrawBox(20 * mi[hen].mojisuutate[sen] + *scrollX, 20 * mi[hen].mojisuuyoko[sen], 20 * (mi[hen].mojisuutate[sen] + 1) + *scrollX, 20 * (mi[hen].mojisuuyoko[sen] + 1), GetColor(0, 255, 0), FALSE);
						}
						//コード2と同じ文字だった場合
						else if (((mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][0] == a[2][0]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][1] == a[2][1]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][2] == a[2][2])) || ((mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][0] == b[2][0]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][1] == b[2][1]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][2] == b[2][2])))
						{
							DrawFormatString(20 * mi[hen].mojisuutate[sen] + 2 + *scrollX, 20 * (mi[hen].mojisuuyoko[sen]) + 2, GetColor(255, 0, 255), "%s", mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]]);
							DrawBox(20 * mi[hen].mojisuutate[sen] + *scrollX, 20 * mi[hen].mojisuuyoko[sen], 20 * (mi[hen].mojisuutate[sen] + 1) + *scrollX, 20 * (mi[hen].mojisuuyoko[sen] + 1), GetColor(255, 0, 255), FALSE);
						}
						//コード3と同じ文字だった場合
						else if (((mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][0] == a[3][0])&& (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][1] == a[3][1])&& (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][2] == a[3][2])) || ((mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][0] == b[3][0]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][1] == b[3][1]) && (mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][2] == b[3][2])))
						{
							DrawFormatString(20 * mi[hen].mojisuutate[sen] + 2 + *scrollX, 20 * (mi[hen].mojisuuyoko[sen]) + 2, GetColor(255, 0, 0), "%s", mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]]);
							DrawBox(20 * mi[hen].mojisuutate[sen] + *scrollX, 20 * mi[hen].mojisuuyoko[sen], 20 * (mi[hen].mojisuutate[sen] + 1) + *scrollX, 20 * (mi[hen].mojisuuyoko[sen] + 1), GetColor(255, 0,0), FALSE);
						}
						//当てはまらなかった場合
						else 
						{
							DrawFormatString(20 * mi[hen].mojisuutate[sen] + 2 + *scrollX, 20 * (mi[hen].mojisuuyoko[sen]) + 2, GetColor(255, 255, 255), "%s", mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]]);
							DrawBox(20 * mi[hen].mojisuutate[sen] + *scrollX, 20 * mi[hen].mojisuuyoko[sen], 20 * (mi[hen].mojisuutate[sen] + 1) + *scrollX, 20 * (mi[hen].mojisuuyoko[sen] + 1), GetColor(255, 255, 255), FALSE);
					    }
					
				}
				//点滅状態
				if (mi[hen].Appearance[sen] > 0)
				{
					
						//3で割った時
						if (*breaktime / 2 == 1)
						{
							DrawFormatString(20 * mi[hen].mojisuutate[sen] + 2 + *scrollX, 20 * (mi[hen].mojisuuyoko[sen]) + 2, GetColor(255, 255, 255), "%s", mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]]);
							--*breaktime;
						}
						else {
							--*breaktime;
						}
						--mi[hen].Appearance[sen];
					
				}


			}
			sen = 0;
		}
	}
	else
	//チュートリアル
	{
		int en = 0;
		for (int len = 0; len < MAPYOKO; len++)
		{

			for (int sen = 0; sen < MAPTATE; sen++)
			{
				if(tutorial[len][sen] == 30)
				{
					if (maji[len].letter[sen][0] == -52)
					{
						char a[3] = "ん";
						for (int n = 0; n < 3; n++)
						{
							maji[len].letter[sen][n] = a[n];
						}
					}
					DrawFormatString(20 * len+2+*scrollX,20 *sen+2, GetColor(255, 255, 0), "%s",maji[len].letter[sen]);
					DrawBox(20 * len + *scrollX, 20 * sen, 20 * (len + 1) + *scrollX, 20 * (sen + 1), GetColor(255, 255, 0), FALSE);

				}


			}
		}
		int sen = 0;
		for (int hen = 0; hen * 24 < *brox; hen++)
		{
			for (sen = 0; hen * 24 + sen < *brox&&sen < 24; sen++)
			{
				DrawFormatString(20 * mi[hen].mojisuutate[sen] + 2 + *scrollX, 20 * (mi[hen].mojisuuyoko[sen]) + 2, GetColor(255, 255, 0), "%s", "");
				DrawBox(20 * mi[hen].mojisuutate[sen] + *scrollX, 20 * mi[hen].mojisuuyoko[sen], 20 * (mi[hen].mojisuutate[sen] + 1) + *scrollX, 20 * (mi[hen].mojisuuyoko[sen] + 1), GetColor(255, 255, 0), FALSE);

			}
		}

	}

	 

	//画面、ステージ描画
	ui(mi, en,timermin,timersec,scrollX,scrollY,stage,shockwave,seen,im);


	if (en[0].finishtime < -1)
	{
		//敵処理
		teki(en, brox, mi, PlayerX, PlayerY, scrollX, scrollY, im, seen);
	}
	
	//チュートリアル  ゴール/////////////////////////
	for (int gon = 0; gon < MAPYOKO; gon++)
	{

		for (int sen = 0; sen < MAPTATE; sen++)
		{
			if (tutorial[gon][sen] == 50)
			{
				if (gon * 20 + *scrollX == 301)
				{
					//チュートリアルをプレイしていた場合
					if (*stage == 0)
					{
						if ((gon * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (gon + 1) * 20 + *scrollX) && (sen * 20 <= *PlayerY + 20) && (*PlayerY <= (sen + 1) * 20))
						{
							//リザルトへ
							*myreturn = RESULT;
							infor->tutoria = 1;
						}
					}
				}
			
			}
		}
	}
	//ゴールが出現していたら
	if (seen->goalappearanceX > -1)
	{
		DrawRotaGraph(seen->goalappearanceX + *scrollX, seen->goalappearanceY, 0.2f, 0, im->gh[28], TRUE);

		if ((seen->goalappearanceX + *scrollX <= *PlayerX + 20) && (*PlayerX <= seen->goalappearanceX + 20 + *scrollX) && (seen->goalappearanceY <= *PlayerY + 20) && (*PlayerY <= seen->goalappearanceY + 20))
		{
			
				if (!(*stage == 0))
				{
					infor->clear[*stage % 10] = 1;
				}
				//リザルトへ
				*myreturn = RESULT;
				
	
		}
	}
	if (mi[0].Playerlife == 0)
	{
		*myreturn = RESULT;
	}
}

//フレームウエイト関数
void Framewait(void)
{
	ScreenFlip();
}

//言葉比較
void comparison(MOJI *mi,int *brox,int *scrollX,int *scrollY,MAPMOJI * maji,int *stage,ENEMY *en)
{
	//時間習得
	DATEDATA Date;
	GetDateTime(&Date);
	char hikaku[MOJISUU];
	{
		int sen = 0;
		int gen = 0;
		for (gen = 0; gen * 24 < *brox; gen++)
		{
			for (int len = 0; gen * 24 + len < *brox&&sen < 24; len++)
			{

				for (int hen = 0; hen * 24 < *brox; hen++)
				{
					for (sen = 0; hen * 24 + sen < *brox&&sen < 24; sen++)
					{
						//できた単語が上から下、または右から左の場合
						if ((((mi[hen].mojisuutate[sen]) == (mi[gen].mojisuutate[len]) + 1) && (mi[hen].mojisuuyoko[sen] == mi[gen].mojisuuyoko[len])) || ((mi[hen].mojisuutate[sen] == mi[gen].mojisuutate[len]) && (mi[hen].mojisuuyoko[sen] == (mi[gen].mojisuuyoko[len]) + 1)))
						{
							//点滅状態では反応させない
							if ((mi[hen].Appearance[sen] == 0) && (mi[hen].Appearance[sen] == 0))
							{
								for (int men = 0; men < 3; men++)
								{
									if (!(men == 2))
									{
										hikaku[men] = mi[mi[gen].mojisuutate[len]].moji[mi[gen].mojisuuyoko[len]][men];
									}

									hikaku[men + 2] = mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][men];
								}
								for (int ken = 0; ken < MOJICODE; ken++)
								{
									//できた単語がアイテムだった場合
									if ((mi[ken].code[0] == hikaku[0]) && (mi[ken].code[1] == hikaku[1]) && (mi[ken].code[2] == hikaku[2]) && (mi[ken].code[3] == hikaku[3]) && (mi[ken].code[4] == hikaku[4]))
									{

										int owari = 0;
										for (int men = 0; men < 32 && owari == 0; men++)
										{
											if (mi[men].aitemX < -1)
											{
												mi[men].aitemX = mi[gen].mojisuutate[len];
												mi[men].aitemY = mi[hen].mojisuuyoko[sen];
												mi[men].oldaitemX = mi[gen].mojisuutate[len] - 1;
												mi[men].oldaitemY = mi[hen].mojisuuyoko[sen] - 1;
												owari = 1;
												mi[men].weapon = ken;    //武器の種類
												mi[men].durable = 3;
												mi[men].have = 0;
											}
										}

									
										//mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][0] = z;
										//mi[mi[gen].mojisuutate[len]].moji[mi[gen].mojisuuyoko[len]][0] = z;
										//アイテムになった文字ブロックの初期化
										mi[hen].mojisuutate[sen] = -2;
										mi[hen].mojisuuyoko[sen] = -2;
										mi[gen].mojisuutate[len] = -2;
										mi[gen].mojisuuyoko[len] = -2;


									}
								}
								
								for (int ken = 0; ken < MOJICODE; ken++)
								{
									//できた単語が敵だった場合
									if ((en[ken].enemycode[0] == hikaku[0]) && (en[ken].enemycode[1] == hikaku[1]) && (en[ken].enemycode[2] == hikaku[2]) && (en[ken].enemycode[3] == hikaku[3]) && (en[ken].enemycode[4] == hikaku[4]))
									{
										int owari = 0;
										for (int men = 0; men < 32 && owari == 0; men++)
										{
											if (en[men].enemyX < -1)
											{
												en[men].enemyX = mi[gen].mojisuutate[len];
												en[men].enemyY = mi[hen].mojisuuyoko[sen];
												owari = 1;
												en[men].enemytype = ken + 10;
												if (en[men].timer < -1)
												{
													en[men].timer = Date.Sec;
												}
											}
											//アイテムになった文字ブロックの初期化
											mi[hen].mojisuutate[sen] = -2;
											mi[hen].mojisuuyoko[sen] = -2;
											mi[gen].mojisuutate[len] = -2;
											mi[gen].mojisuuyoko[len] = -2;
										}




									}
							
								}
							}
						}
						if (!(len == 0))
						{
							//できた単語が左から右、または下から上の場合
							if ((((mi[hen].mojisuutate[sen]) == (mi[gen].mojisuutate[len]) - 1) && (mi[hen].mojisuuyoko[sen] == mi[gen].mojisuuyoko[len])) || ((mi[hen].mojisuutate[sen] == mi[gen].mojisuutate[len]) && (mi[hen].mojisuuyoko[sen] == (mi[gen].mojisuuyoko[len]) - 1)))
							{
								//点滅状態では反応させない
								if ((mi[hen].Appearance[sen] == 0) && (mi[hen].Appearance[sen] == 0))
								{
									for (int men = 0; men < 3; men++)
									{
										if (!(men == 2))
										{
											hikaku[men] = mi[mi[gen].mojisuutate[len]].moji[mi[gen].mojisuuyoko[len]][men];
										}

										hikaku[men + 2] = mi[mi[hen].mojisuutate[sen]].moji[mi[hen].mojisuuyoko[sen]][men];
									}

									for (int ken = 0; ken < MOJICODE; ken++)
									{
										//できた単語がアイテムだった場合
										if ((mi[ken].code[0] == hikaku[0]) && (mi[ken].code[1] == hikaku[1]) && (mi[ken].code[2] == hikaku[2]) && (mi[ken].code[3] == hikaku[3]) && (mi[ken].code[4] == hikaku[4]))
										{

											int owari = 0;
											for (int men = 0; men < 32 && owari == 0; men++)
											{
												if (mi[men].aitemX < -1)
												{
													mi[men].aitemX = mi[gen].mojisuutate[len];
													mi[men].aitemY = mi[hen].mojisuuyoko[sen];
													mi[men].oldaitemX = mi[gen].mojisuutate[len] - 1;
													mi[men].oldaitemY = mi[hen].mojisuuyoko[sen] - 1;
													owari = 1;
													mi[men].weapon = ken;  //武器の種類
													mi[men].durable = 3;
													mi[men].have = 0;
													if (ken == 4)
													{
														mi[men].durable = 20;
													}
												}
											}

											int z = 'z';
											
											mi[hen].mojisuutate[sen] = -2;
											mi[hen].mojisuuyoko[sen] = -2;
											mi[gen].mojisuutate[len] = -2;
											mi[gen].mojisuuyoko[len] = -2;


										}
									}
									for (int ken = 0; ken < MOJICODE; ken++)
									{
										//できた単語が敵だった場合
										if ((en[ken].enemycode[0] == hikaku[0]) && (en[ken].enemycode[1] == hikaku[1]) && (en[ken].enemycode[2] == hikaku[2]) && (en[ken].enemycode[3] == hikaku[3]) && (en[ken].enemycode[4] == hikaku[4]))
										{
											int owari = 0;
											for (int men = 0; men < 32 && owari == 0; men++)
											{
												if (en[men].enemyX < -1)
												{
													en[men].enemyX = mi[gen].mojisuutate[len];
													en[men].enemyY = mi[hen].mojisuuyoko[sen];
													owari = 1;
													en[men].enemytype = ken + 10;
													if (en[men].timer < -1)
													{
														en[men].timer = Date.Sec;
													}
												}
												//アイテムになった文字ブロックの初期化
												mi[hen].mojisuutate[sen] = -2;
												mi[hen].mojisuuyoko[sen] = -2;
												mi[gen].mojisuutate[len] = -2;
												mi[gen].mojisuuyoko[len] = -2;
											}




										}

									}
								}
							}
						}

					}

				}

			}
		}
	}



	/////チュートリアル/////////////////////////////////////
	for (int len = 0; len < MAPYOKO; len++)
	{

		for (int sen = 0; sen < MAPTATE; sen++)
		{
			if (tutorial[len][sen] == 30)
			{
				//できた単語が上から下、または右から左の場合
				if (tutorial[len+1][sen] == 30)
				{
					
						for (int men = 0; men < 3; men++)
						{
							if (!(men == 2))
							{
								hikaku[men] = maji[len].letter[sen][men];
							}

							hikaku[men + 2] = maji[len+1].letter[sen][men];
						}
						for (int ken = 0; ken < MOJICODE; ken++)
						{
							if ((mi[ken].code[0] == hikaku[0]) && (mi[ken].code[1] == hikaku[1]) && (mi[ken].code[2] == hikaku[2]) && (mi[ken].code[3] == hikaku[3]) && (mi[ken].code[4] == hikaku[4]))
							{

								int owari = 0;
								for (int men = 0; men < 32 && owari == 0; men++)
								{
									if (mi[men].aitemX < -1)
									{
										mi[men].aitemX = len;
										mi[men].aitemY = sen;
										mi[men].oldaitemX = len - 1;
										mi[men].oldaitemY = sen - 1;
										owari = 1;
										mi[men].weapon = ken;    //武器の種類
										mi[men].durable = 3;
										mi[men].have = 0;
									}
								}

								tutorial[len][sen] = 0;
								tutorial[len+1][sen] = 0;
							}
						}
					
				}
				//できた単語が上から下、または右から左の場合
				if (tutorial[len][sen+1] == 30)
				{

					for (int men = 0; men < 3; men++)
					{
						if (!(men == 2))
						{
							hikaku[men] = maji[len].letter[sen][men];
						}

						hikaku[men + 2] = maji[len].letter[sen+1][men];
					}
					for (int ken = 0; ken < MOJICODE; ken++)
					{
						if ((mi[ken].code[0] == hikaku[0]) && (mi[ken].code[1] == hikaku[1]) && (mi[ken].code[2] = hikaku[1]) && (mi[ken].code[3] == hikaku[3]) && (mi[ken].code[4] == hikaku[4]))
						{

							int owari = 0;
							for (int men = 0; men < 32 && owari == 0; men++)
							{
								if (mi[men].aitemX < -1)
								{
									mi[men].aitemX = len;
									mi[men].aitemY = sen;
									mi[men].oldaitemX = len - 1;
									mi[men].oldaitemY = sen - 1;
									owari = 1;
									mi[men].weapon = ken;    //武器の種類
									mi[men].durable = 3;
									mi[men].have = 0;
								}
							}


							tutorial[len][sen] = 0;
							tutorial[len][sen+1] = 0;
						}
					}

				}
					
			}
		}
	}

	
}


void atari(MOJI *mi)
{

}




void ui(MOJI *mi,ENEMY *en,int *timermin,int *timersec,int *scrollX,int *scrollY,int *stage,int *shockwave,SCREEN *seen,IMAGE *im)
{
	//時間習得
	DATEDATA Date;
	GetDateTime(&Date);
	if (!(*timersec == Date.Sec))
	{
		*timersec += 1;
	}
	if (*timersec == 60)
	{
		
	}

		



	switch (*stage)
	{
		//チュートリアル
	case 0:
		//マップDRAW
		for (int len = 0; len < MAPYOKO; len++)
		{

			for (int sen = 0; sen < MAPTATE; sen++)
			{
				if (tutorial[len][sen] == 1)
				{

					DrawBox(20 * len + *scrollX, 20 * sen, 20 * (len + 1) + *scrollX, 20 * (sen + 1), GetColor(255, 255, 0), FALSE);
				}
				//操作説明
				if (tutorial[len][sen] == 300)
				{
						DrawFormatString(20 * len + *scrollX, 20 * sen, GetColor(255, 255, 0), "%s", "チュートリアル@");
						DrawFormatString(20 * len + *scrollX, 20 * sen+20, GetColor(255, 255, 0), "%s", "左右の矢印キーで移動します。");
						DrawFormatString(20 * len + *scrollX, 20 * sen + 40, GetColor(255, 255, 0), "%s", "まずは右に行こう");
					
				}
				if (tutorial[len][sen] == 301)
				{
					DrawFormatString(20 * len + *scrollX, 20 * sen, GetColor(255, 255, 0), "%s", "チュートリアルA");
					DrawFormatString(20 * len + *scrollX, 20 * sen + 20, GetColor(255, 255, 0), "%s", "ENTERキーでジャンプします。");

				}
				if (tutorial[len][sen] == 302)
				{
					DrawFormatString(20 * len + *scrollX, 20 * sen, GetColor(255, 255, 0), "%s", "チュートリアルB");
					DrawFormatString(20 * len + *scrollX, 20 * sen + 20, GetColor(255, 255, 0), "%s", "zキーで文字を発射できます。");
					DrawFormatString(20 * len + *scrollX, 20 * sen + 40, GetColor(255, 255, 0), "%s", "左上に出ている文字が左から順に発射されます。");
				}
				if (tutorial[len][sen] == 303)
				{
					DrawFormatString(20 * len + *scrollX, 20 * sen, GetColor(255, 255, 0), "%s", "チュートリアルC");
					DrawFormatString(20 * len + *scrollX, 20 * sen + 20, GetColor(255, 255, 0), "%s", "上矢印キーで装備するアイテムを\n変えることができます。");

				}
				if (tutorial[len][sen] == 304)
				{
					DrawFormatString(20 * len + *scrollX, 20 * sen, GetColor(255, 255, 0), "%s", "チュートリアルD");
					DrawFormatString(20 * len + *scrollX, 20 * sen + 20, GetColor(255, 255, 0), "%s", "特定の言葉を作ることでアイテムを\n獲得することができます。");
					
				}
				if (tutorial[len][sen] == 305)
				{
					DrawFormatString(20 * len + *scrollX, 20 * sen, GetColor(255, 255, 0), "%s", "チュートリアルE");
					DrawFormatString(20 * len + *scrollX, 20 * sen+20, GetColor(255, 255, 0), "%s", "獲得したアイテムで\n敵を倒してみよう");

				}
				if (tutorial[len][sen] == 306)
				{
					DrawFormatString(20 * len + *scrollX, 20 * sen, GetColor(255, 255, 0), "%s", "文字ブロックを駆使して、敵を倒し、ゴールを目指そう");
					DrawFormatString(20 * len + *scrollX, 20 * sen+20, GetColor(255, 255, 0), "%s", "チュートリアルはオプションから見ることができます。");

				}

				//敵初期位置
				if (tutorial[len][sen] == 14)
				{
					int owari = 0;
					for (int ken = 0; ken < 32 && owari == 0; ken++)
					{
						if (!(en[ken].appearanceX < -1))
						{
							if ((len == en[ken].appearanceX) && (sen == en[ken].appearanceY))
							{
								owari = 1;
							}
						}
						else
						{
							en[ken].enemyX = len;
							en[ken].enemyY = sen;
							en[ken].enemytype = 1;
							owari = 1;
							if (en[ken].timer < -1)
							{
								en[ken].timer = Date.Sec;
							}
							en[ken].appearanceX = len;
							en[ken].appearanceY = sen;
						}

					}


				}
				//ゴール//////////////////
				if (tutorial[len][sen] == 50)
				{
					if (seen->goalup < 0)
					{
						seen->goalup = sen;
					}
					seen->goaldawn = sen;
					if (seen->goallen < 0)
					{
						seen->goallen = len;
					}
					
				}

				//衝撃波初期値
				if (tutorial[len][sen] == 100)
				{
					++*shockwave;
					DrawBox(20 * len - *shockwave + *scrollX, 20 * sen - *shockwave, 20 * (len + 1) + *shockwave + *scrollX, 20 * (sen + 1) + *shockwave, GetColor(255, 0, 255), FALSE);

					if (*shockwave == 30)
					{
						*shockwave = 0;
					}
				}
			}
		}
		DrawExtendGraph(20 * seen->goallen + *scrollX, 20 * seen->goalup, 20 * (seen->goallen + 1) + *scrollX, 20 * (seen->goaldawn + 1), im->gh[5], TRUE);
		break;
	case  11:
		//マップDRAW
		for (int len = 0; len < MAPYOKO; len++)
		{

			for (int sen = 0; sen < MAPTATE; sen++)
			{
				if (MAP1_1[len][sen] == 1)
				{

					DrawBox(20 * len + *scrollX, 20 * sen, 20 * (len + 1) + *scrollX, 20 * (sen + 1), GetColor(255, 255, 0), TRUE);
				}
				//ゴール
				if (MAP1_1[len][sen] == 4)
				{
					DrawBox(20 * len, 20 * sen, 20 * (len + 1), 20 * (sen + 1), GetColor(255, 0, 255), TRUE);
				}
				//敵初期位置
				if (MAP1_1[len][sen] == 14)
				{
					int owari = 0;
					for (int ken = 0; ken < 32 && owari == 0; ken++)
					{
						if (!(en[ken].appearanceX < -1))
						{
							if ((len == en[ken].appearanceX) && (sen == en[ken].appearanceY))
							{
								owari = 1;
							}
						}
						else
						{
							en[ken].enemyX = len;
							en[ken].enemyY = sen;
							en[ken].enemytype = 1;
							owari = 1;
							if (en[ken].timer < -1)
							{
								en[ken].timer = Date.Sec;
							}
							en[ken].appearanceX = len;
							en[ken].appearanceY = sen;
						}

					}
				}

				if (MAP1_1[len][sen] == 15)
				{
					int owari = 0;
					for (int ken = 0; ken < 32 && owari == 0; ken++)
					{
						if (!(en[ken].appearanceX < -1))
						{
							if ((len == en[ken].appearanceX) && (sen == en[ken].appearanceY))
							{
								owari = 1;
							}
						}
						else
						{
							en[ken].enemyX = len;
							en[ken].enemyY = sen;
							en[ken].enemytype = 2;
							owari = 1;
							if (en[ken].timer < -1)
							{
								en[ken].timer = Date.Sec;
							}
							en[ken].appearanceX = len;
							en[ken].appearanceY = sen;
						}

					}
				}
				//装飾
				if (MAP1_1[len][sen] == 90)
				{
					DrawRotaGraph(20 * len + *scrollX, 20 * sen, 0.3f, 0, im->gh[13], TRUE);
				}


				//衝撃波初期値
				if (MAP1_1[len][sen] == 100)
				{
					++*shockwave;
					DrawBox(20 * len - *shockwave + *scrollX, 20 * sen - *shockwave, 20 * (len + 1) + *shockwave + *scrollX, 20 * (sen + 1) + *shockwave, GetColor(255, 0, 255), FALSE);

					if (*shockwave == 30)
					{
						*shockwave = 0;
					}
				}
			}
		}
		break;
	case  12:
		//マップDRAW
		for (int len = 0; len < MAPYOKO; len++)
		{

			for (int sen = 0; sen < MAPTATE; sen++)
			{
				if (MAP1_2[len][sen] == 1)
				{

					DrawBox(20 * len + *scrollX, 20 * sen, 20 * (len + 1) + *scrollX, 20 * (sen + 1), GetColor(255, 255, 0), FALSE);
				}
				//ゴール
				if (MAP1_2[len][sen] == 4)
				{
					DrawBox(20 * len, 20 * sen, 20 * (len + 1), 20 * (sen + 1), GetColor(255, 0, 255), TRUE);
				}
				//敵初期位置
				if (MAP1_2[len][sen] == 11)
				{
					int owari = 0;
					for (int ken = 0; ken < 32 && owari == 0; ken++)
					{
						if (!(en[ken].appearanceX < -1))
						{
							if ((len == en[ken].appearanceX) && (sen == en[ken].appearanceY))
							{
								owari = 1;
							}
						}
						else
						{
							en[ken].enemyX = len;
							en[ken].enemyY = sen;
							en[ken].enemytype = 1;
							owari = 1;
							if (en[ken].timer < -1)
							{
								en[ken].timer = Date.Sec;
							}
							en[ken].appearanceX = len;
							en[ken].appearanceY = sen;
						}

					}






				}

				if (MAP1_2[len][sen] == 16)
				{
					int owari = 0;
					for (int ken = 0; ken < 32 && owari == 0; ken++)
					{
						if (!(en[ken].appearanceX < -1))
						{
							if ((len == en[ken].appearanceX) && (sen == en[ken].appearanceY))
							{
								owari = 1;
							}
						}
						else
						{
							en[ken].enemyX = len;
							en[ken].enemyY = sen;
							en[ken].enemytype = 3;
							owari = 1;
							if (en[ken].timer < -1)
							{
								en[ken].timer = Date.Sec;
							}
							en[ken].appearanceX = len;
							en[ken].appearanceY = sen;
						}

					}
				}
			}
		}
		//ゴール
	
		break;


	case  13:
		//マップDRAW
		for (int len = 0; len < MAPYOKO; len++)
		{

			for (int sen = 0; sen < MAPTATE; sen++)
			{
				if (MAP1_3[len][sen] == 1)
				{

					DrawBox(20 * len + *scrollX, 20 * sen, 20 * (len + 1) + *scrollX, 20 * (sen + 1), GetColor(255, 255, 0), FALSE);
				}
				//ゴール
				if (MAP1_3[len][sen] == 4)
				{
					DrawBox(20 * len, 20 * sen, 20 * (len + 1), 20 * (sen + 1), GetColor(255, 0, 255), TRUE);
				}
				//敵初期位置
				if (MAP1_3[len][sen] == 11)
				{
					int owari = 0;
					for (int ken = 0; ken < 32 && owari == 0; ken++)
					{
						if (!(en[ken].appearanceX < -1))
						{
							if ((len == en[ken].appearanceX) && (sen == en[ken].appearanceY))
							{
								owari = 1;
							}
						}
						else
						{
							en[ken].enemyX = len;
							en[ken].enemyY = sen;
							en[ken].enemytype = 1;
							owari = 1;
							if (en[ken].timer < -1)
							{
								en[ken].timer = Date.Sec;
							}
							en[ken].appearanceX = len;
							en[ken].appearanceY = sen;
						}

					}






				}

				if (MAP1_3[len][sen] == 17)
				{
					int owari = 0;
					for (int ken = 0; ken < 32 && owari == 0; ken++)
					{
						if (!(en[ken].appearanceX < -1))
						{
							if ((len == en[ken].appearanceX) && (sen == en[ken].appearanceY))
							{
								owari = 1;
							}
						}
						else
						{
							en[ken].enemyX = len;
							en[ken].enemyY = sen;
							en[ken].enemytype = 4;
							owari = 1;
							if (en[ken].timer < -1)
							{
								en[ken].timer = Date.Sec;
							}
							en[ken].appearanceX = len;
							en[ken].appearanceY = sen;
						}

					}
				}
				if (MAP1_3[len][sen] == 91)
				{
					DrawRotaGraph(20 * len + *scrollX, 20 * sen, 0.4f, 0, im->gh[17], TRUE);
				}
				//装飾
				if (MAP1_3[len][sen] == 92)
				{
					DrawRotaGraph(20 * len + *scrollX, 20 * sen, 0.4f, 0, im->gh[20], TRUE);
				}
			}
		}
		//ゴール

		break;
	case  14:
		//マップDRAW
		for (int len = 0; len < MAPYOKO; len++)
		{

			for (int sen = 0; sen < MAPTATE; sen++)
			{
				if (MAP1_3[len][sen] == 1)
				{

					DrawBox(20 * len + *scrollX, 20 * sen, 20 * (len + 1) + *scrollX, 20 * (sen + 1), GetColor(255, 255, 0), FALSE);
				}
				//ゴール
				if (MAP1_3[len][sen] == 4)
				{
					DrawBox(20 * len, 20 * sen, 20 * (len + 1), 20 * (sen + 1), GetColor(255, 0, 255), TRUE);
				}
				//敵初期位置
				if (MAP1_4[len][sen] == 11)
				{
					int owari = 0;
					for (int ken = 0; ken < 32 && owari == 0; ken++)
					{
						if (!(en[ken].appearanceX < -1))
						{
							if ((len == en[ken].appearanceX) && (sen == en[ken].appearanceY))
							{
								owari = 1;
							}
						}
						else
						{
							en[ken].enemyX = len;
							en[ken].enemyY = sen;
							en[ken].enemytype = 1;
							owari = 1;
							if (en[ken].timer < -1)
							{
								en[ken].timer = Date.Sec;
							}
							en[ken].appearanceX = len;
							en[ken].appearanceY = sen;
						}

					}

				}

				if (MAP1_4[len][sen] == 18)
				{
					int owari = 0;
					for (int ken = 0; ken < 32 && owari == 0; ken++)
					{
						if (!(en[ken].appearanceX < -1))
						{
							if ((len == en[ken].appearanceX) && (sen == en[ken].appearanceY))
							{
								owari = 1;
							}
						}
						else
						{
							en[ken].enemyX = len;
							en[ken].enemyY = sen;
							en[ken].enemytype = 5;
							owari = 1;
							if (en[ken].timer < -1)
							{
								en[ken].timer = Date.Sec;
							}
							en[ken].appearanceX = len;
							en[ken].appearanceY = sen;
						}

					}


				}

			}
		}
		break;
	}

	//ゲームスクリーンDRAW
	for (int len = 0; len < MAPYOKO; len++)
	{

		for (int sen = 0; sen < MAPTATE; sen++)
		{
			if (gamescreen[len][sen] == 1)
			{

				DrawBox(20 * len, 20 * sen, 20 * (len + 1), 20 * (sen + 1), GetColor(255, 255, 0), FALSE);
			}
			if (gamescreen[len][sen] == 10)
			{
				DrawBox(20 * len, 20 * sen, 20 * (len + 1), 20 * (sen + 1), GetColor(0, 255, 0), TRUE);

			}
			if (gamescreen[len][sen] == 14)
			{
				DrawFormatString(20 * len, 20 * sen, GetColor(255, 255, 255), "%d", *timersec);
				DrawFormatString(20 * len+20, 20 * sen+20, GetColor(255, 255, 255), "%d", *timermin%100);
			}
			if (gamescreen[len][sen] == 15)
			{
				int fontSize = 30;
				SetFontSize(fontSize);
				//弾に入っている文字表示
				for (int men = 0; men < 5; men++)
				{
					
					DrawFormatString(len * (20+men*10), sen*20, GetColor(255, 255, 255), "%s", mi[0].tama[men]);
				}
				fontSize = 18;
				SetFontSize(fontSize);
			}
			if (gamescreen[len][sen] == 16)
			{
				DrawRotaGraph(20 * len + *scrollX, 20 * sen, 0.4f, 0, im->gh[35], TRUE);


			}
			if (gamescreen[len][sen] == 40)
			{
				DrawBox(20 * len, 20 * sen, 20 * (len + 1), 20 * (sen + 1), GetColor(0, 0, 255), TRUE);
			}
			if (gamescreen[len][sen] == 45)
			{
				if (*stage == 0)
				{
					DrawFormatString(len * 20, sen * 20, GetColor(255, 255, 255), "%s", "チュートリアル");
				}
				else
				{
					DrawFormatString(len * 20, sen * 20, GetColor(255, 255, 255), "%d -　%dステージ", *stage/10,*stage%10);
				}

			}
			if (gamescreen[len][sen] == 70)
			{
				if (seen->hpbarLEFT < -1)
				{
					seen->hpbarLEFT = len;
				}
				
				seen->hpbarRIGHT = len+1;
				
				if (seen->hpbarUP < -1)
				{
					seen->hpbarUP = sen;
				}
				
				DrawBox(len * 20, sen * 20, (len + 1) * 20, (sen + 1) * 20, GetColor(255, 255, 255), TRUE);
					
			}
			if (gamescreen[len][sen] == 71)
			{
				DrawFormatString(len * 20, sen * 20, GetColor(255, 255, 255), "HP      %d /　%d", en->enemyLife, en->MAXLife);
			}
			if (gamescreen[len][sen] == 72)
			{
				if (seen->enemyimageUP < -1)
				{
					seen->enemyimageUP = sen;
				}
				seen->enemyimageDAWN = sen + 1;
				if (seen->enemyimageLEFT < -1)
				{
					seen->enemyimageLEFT = len;
				}
				seen->enemyimageRIGHT = len +1;
			}
			if (gamescreen[len][sen] == 73)
			{
				DrawFormatString(len * 20, sen * 20, GetColor(255, 255, 255), "NAME     %s", en->enemyname);
			}
			if ((gamescreen[len][sen] == 74)&&(seen->LIFE < mi[0].Playerlife))
			{
				if (seen->LIFE < -1)
				{
					seen->LIFE = 1;
				}
				else
				{
					++seen->LIFE;
				}
				if ((seen->LIFE == 3)&&(mi[0].Playerlife  > 3))
				{
					DrawRotaGraph(len * 20, sen * 20, 0.2f, 0, im->gh[19], TRUE);
				}
				else if ((seen->LIFE == 2) && (mi[0].Playerlife > 4))
				{
					DrawRotaGraph(len * 20, sen * 20, 0.2f, 0, im->gh[19], TRUE);
				}
				else if ((seen->LIFE == 1) && (mi[0].Playerlife > 5))
				{
					DrawRotaGraph(len * 20, sen * 20, 0.2f, 0, im->gh[19], TRUE);
				}
				else
				{
					DrawRotaGraph(len * 20, sen * 20, 0.2f, 0, im->gh[6], TRUE);

				}
				
				
			}
		}
	}
	DrawFormatString(39, 20, GetColor(255, 255, 255), "%s", "メニ\nュー\nへ戻る");
	seen->LIFE = -2;
	//敵画像表示
	for (int men = 0; men < 32; men++)
	{
		if (en[men].enemytype > 1)
		{
			if (en[men].enemytype == 2)
			{
				DrawExtendGraph(seen->enemyimageLEFT * 20, seen->enemyimageUP * 20, seen->enemyimageRIGHT * 20, seen->enemyimageDAWN * 20, im->gh[7], TRUE);
			}
			if (en[men].enemytype == 3)
			{
				DrawExtendGraph(seen->enemyimageLEFT * 20, seen->enemyimageUP * 20,seen->enemyimageRIGHT * 20, seen->enemyimageDAWN * 20, im->gh[9], TRUE);
			}
			if (en[men].enemytype == 4)
			{
				DrawExtendGraph(seen->enemyimageLEFT * 20, seen->enemyimageUP * 20, seen->enemyimageRIGHT * 20, seen->enemyimageDAWN * 20, im->gh[11], TRUE);
			}
			if (en[men].enemytype == 5)
			{
				DrawExtendGraph(seen->enemyimageLEFT * 20, seen->enemyimageUP * 20, seen->enemyimageRIGHT * 20, seen->enemyimageDAWN * 20, im->gh[36], TRUE);

			}
		}
	}
	//敵hpバー表示
	seen->hpbarRIGHT = seen->hpbarRIGHT - seen->hpbarLEFT;
	int owari = 0;
	for (int len = 0; len < 32&&owari == 0; len++)
	{
		if (en->enemytype > 1)
		{
			if (en->enemyLife > -1)
			{
				seen->hpbarRIGHT = seen->hpbarRIGHT / en->MAXLife;
				DrawBox(seen->hpbarLEFT * 20, seen->hpbarUP * 20,(seen->hpbarLEFT*20)+seen->hpbarRIGHT * en->enemyLife *20,(seen->hpbarUP+1) * 20, GetColor(2, 0, 0), TRUE);
				owari = 1;
			}
		}
	}
	

}



void teki(ENEMY *en,int *brox,MOJI *mi,int *PlayerX,int *PlayerY,int *scrollX,int *scrollY,IMAGE *im,SCREEN *seen)
{
	//時間習得
	DATEDATA Date;
	GetDateTime(&Date);

	
	for (int len = 0; len < 32; len++)
	{
		if (!(en[len].enemyX < -1))
		{
			
				
			switch (en[len].enemytype)
			{
			case 1:
				//雑魚
			{
				char z[20] = { "おおネズミ" };
				for (int n = 0; n < 10; n++)
				{
					en[len].enemyname[n] = z[n];
				}
			}
			if (en[len].oldenemyX < -1)
			{
				en[len].oldenemyX = en[len].enemyX - 1;
				en[len].oldenemyY = en[len].enemyY - 1;
				en[len].starttime = 150;
			}
			{
				int sen = 0;
				for (int hen = 0; hen * 24 < *brox; hen++)
				{
					for (sen = 0; hen * 24 + sen < *brox&&sen < 24; sen++)
					{
						//プレイヤー当たり判定
						if ((mi[hen].mojisuutate[sen] * 20 <= en[len].enemyX * 20 + 20) && (en[len].enemyX * 20 <= (mi[hen].mojisuutate[sen] + 1) * 20) && (mi[hen].mojisuuyoko[sen] * 20 <= en[len].enemyY * 20 + 20) && (en[len].enemyY * 20 <= (mi[hen].mojisuuyoko[sen] + 1) * 20))
						{
							if (en[len].enemyX < en[len].oldenemyX)
							{
								en[len].oldenemyX = en[len].enemyX;
								en[len].oldenemyY = en[len].enemyY;
								en[len].enemyX = en[len].enemyX + ZAKOSPEED;
							}
							else
							{
								en[len].oldenemyX = en[len].enemyX;
								en[len].oldenemyY = en[len].enemyY;
								en[len].enemyX = en[len].enemyX - ZAKOSPEED;
							}

						}
					}
				}

			}
			if (en[len].enemyX < en[len].oldenemyX)
			{
				en[len].oldenemyX = en[len].enemyX;
				en[len].oldenemyY = en[len].enemyY;

				//プレイヤーが範囲内にいた場合加速
				if ((en[len].enemyX * 20 - 500 <= *PlayerX) && (en[len].enemyX * 20 >= *PlayerX + 20) && (en[len].enemyY * 20 - 100 <= *PlayerY + 20) && (en[len].enemyY * 20 + 100 >= *PlayerY))
				{

					en[len].enemyX = en[len].enemyX - ZAKOSPEED * 5;
				}
				en[len].enemyX = en[len].enemyX - ZAKOSPEED;
			}
			else
			{
				en[len].oldenemyX = en[len].enemyX;
				en[len].oldenemyY = en[len].enemyY;
				//プレイヤーが範囲内にいた場合加速
				if ((en[len].enemyX * 20 + 500 >= *PlayerX) && (en[len].enemyX * 20 <= *PlayerX + 20) && (en[len].enemyY * 20 - 100 <= *PlayerY + 20) && (en[len].enemyY * 20 + 100 >= *PlayerY))
				{
					en[len].enemyX = en[len].enemyX + ZAKOSPEED * 5;
				}
				en[len].enemyX = en[len].enemyX + ZAKOSPEED;
			}

			judgement(en, brox, mi, scrollX, scrollY, im);

			en[len].Widthofaction = 1;
			en[len].waittimer = 5;
			en[len].OldLife = en[len].enemyLife;
			break;
			case 2:
			{
				char z[20] = { "魔人" };
				for (int n = 0; n < 10; n++)
				{
					en[len].enemyname[n] = z[n];
				}
			}
			//中ボス
			if (en[len].oldenemyX < -1)
			{
				en[len].oldenemyX = en[len].enemyX - 1;
				en[len].oldenemyY = en[len].enemyY - 1;
				en[len].enemyLife = 7;
				en[len].MAXLife = 7;
				en[len].starttime = 150;
			}
			if (en[len].enemyX * 20 + *scrollX < *PlayerX)
			{
				en[len].enemydirection = RIGHT;
			}
			else
			{
				en[len].enemydirection = LEFT;
			}
	

			judgement(en, brox, mi, scrollX, scrollY, im);
			en[len].Widthofaction = 2;
			en[len].waittimer = 5;
			en[len].OldLife = en[len].enemyLife;
			break;
			case  3:
			{
				char z[20] = { "ペガサス" };
				for (int n = 0; n < 10; n++)
				{
					en[len].enemyname[n] = z[n];
				}
			}
			//中ボス
			if (en[len].oldenemyX < -1)
			{
				en[len].oldenemyX = en[len].enemyX - 1;
				en[len].oldenemyY = en[len].enemyY - 1;
				en[len].enemyLife = 17;
				en[len].MAXLife = 17;
				en[len].starttime = 150;
			}
			if (en[len].enemyX * 20 + *scrollX < *PlayerX)
			{
				en[len].enemydirection = RIGHT;
			}
			else
			{
				en[len].enemydirection = LEFT;
			}
			

			judgement(en, brox, mi, scrollX, scrollY, im);
			en[len].Widthofaction = 4;
			en[len].waittimer = 5;
			en[len].OldLife = en[len].enemyLife;

			break;

			case  4:
			{
				char z[20] = { "ベリアル" };
				for (int n = 0; n < 10; n++)
				{
					en[len].enemyname[n] = z[n];
				}
			}
			//中ボス
			if (en[len].oldenemyX < -1)
			{
				en[len].oldenemyX = en[len].enemyX - 1;
				en[len].oldenemyY = en[len].enemyY - 1;
				en[len].enemyLife = 20;
				en[len].MAXLife = 20;
				en[len].starttime = 150;
			}
			if (en[len].enemyX * 20 + *scrollX < *PlayerX)
			{
				en[len].enemydirection = RIGHT;
			}
			else
			{
				en[len].enemydirection = LEFT;
			}
		

			judgement(en, brox, mi, scrollX, scrollY, im);
			en[len].Widthofaction = 5;
			en[len].waittimer = 5;
			en[len].OldLife = en[len].enemyLife;

			break;
			case 5:
			{
				char z[20] = { "アルファ" };
				for (int n = 0; n < 10; n++)
				{
					en[len].enemyname[n] = z[n];
				}
			}
			//中ボス
			if (en[len].oldenemyX < -1)
			{
				en[len].oldenemyX = en[len].enemyX - 1;
				en[len].oldenemyY = en[len].enemyY - 1;
				en[len].enemyLife = 22;
				en[len].MAXLife = 22;
				en[len].starttime = 150;
			}
			if (en[len].enemyX * 20 + *scrollX < *PlayerX)
			{
				en[len].enemydirection = RIGHT;
			}
			else
			{
				en[len].enemydirection = LEFT;
			}
			

			judgement(en, brox, mi, scrollX, scrollY, im);
			en[len].Widthofaction = 5;
			en[len].waittimer = 5;
			en[len].OldLife = en[len].enemyLife;
			break;
			case 11:
			{
				char z[20] = { "バグ" };
				for (int n = 0; n < 10; n++)
				{
					en[len].enemyname[n] = z[n];
				}
			}

				break;
			}
				
		}
	}


	if (!(en[0].starttime == 0))
	{
		DrawFormatString(200, 200, GetColor(255, 0, 0), "%sをたおせ", en[0].enemyname);
	}
	
		//敵ランダム行動と敵との当たり判定
		for (int len = 0; len < 32; len++)
		{
			
			//スタートから一定時間が経っているか
			if (!(en[len].enemyX < -1) && (en[len].starttime == 0))
			{
				
				en[len].timer = Date.Sec;
				if (en[len].Attackmiddle <= -1)
				{
					en[len].Attackmiddle = GetRand(en[len].Widthofaction);
				}
				int owari = 0;
				switch (en[len].Attackmiddle)
				{
				case 0:
					//PlayerのX座標に移動
					if (en[len].enemytype == 2)
					{
						if (1 == GetRand(2))
						{
							en[len].enemyX = (*PlayerX + *scrollX) / 20;
						}
					}
					en[len].Attackmiddle = -1;
					break;
					//弾を発射
				case 1:
					for (int men = 0; men < 32 && owari == 0; men++)
					{
						if (en[men].enemyballetX < -1)
						{
							en[men].enemyballetX = en[len].enemyX;
							en[men].enemyballetY = en[len].enemyY;
							owari = 1;


							if (en[len].enemytype == 1)
							{
								if (en[len].oldenemyX < en[len].enemyX)
								{

									en[men].enemydirection = RIGHT;
								}
								else
								{
									en[men].enemydirection = LEFT;
								}
							}

						}
					}
					en[len].Attackmiddle = -1;
					break;
					//
				case 2:
				{


					int g = 0;
					int f = 0;
					if (*PlayerX < en[len].enemyX * 20 + *scrollX)
					{
						g = (en[len].enemyX * 20 + *scrollX) - *PlayerX;
						g = g / 3;

					}
					else
					{
						g = *PlayerX - (en[len].enemyX * 20 + *scrollX);
					}

					for (int n = 0; n < 3; n++)
					{
						if (en[len].Attackrange[n] < -1)
						{
							if (*PlayerX < en[len].enemyX * 20 + *scrollX)
							{
								en[len].Attacktimer = 100;
								en[len].Attackrange[n] = en[len].enemyX * 20 - g * (1 + n);
							}
							else
							{
								en[len].Attacktimer = 100;
								en[len].Attackrange[n] = en[len].enemyX * 20 + g * (1 + n);
							}
						}
					}

					if (en[len].Attacktimer == 0)
					{
						for (int n = 0; n < 3; n++)
						{
							if (en[len].AttackSustain[n] < -1)
							{
								en[len].AttackSustain[n] = 0;
							}

							if (en[len].AttackSustain[n] < 280)
							{
								++en[len].AttackSustain[n];
								DrawBox(en[len].Attackrange[n] + *scrollX + 2, 380 - en[len].AttackSustain[n], en[len].Attackrange[n] + *scrollX + 3, 380, GetColor(255, 255, 255), TRUE);
								DrawBox(en[len].Attackrange[n] + *scrollX, 380 - en[len].AttackSustain[n], en[len].Attackrange[n] + *scrollX + 1, 380, GetColor(255, 100, 100), TRUE);
								DrawBox(en[len].Attackrange[n] + *scrollX + 4, 380 - en[len].AttackSustain[n], en[len].Attackrange[n] + *scrollX + 5, 380, GetColor(255, 100, 100), TRUE);
								//当たり判定
								if ((en[len].Attackrange[n] + *scrollX <= *PlayerX + 20) && (*PlayerX <= en[len].Attackrange[n] + *scrollX + 5) && (380 - en[len].AttackSustain[n] <= *PlayerY + 20) && (*PlayerY <= 380) && (mi[0].Playerinvincible == 0))
								{
									--mi[0].Playerlife;
									mi[0].Playerinvincible = 1;
									mi[0].Playerinvincibletime = PLAYERINVINCIBLETIMENUMBER;
									
								}
							}
							if (en[len].AttackSustain[n] == 280)
							{
								//初期化
								en[len].Attackmiddle = -1;
								en[len].AttackSustain[n] = -2;
								en[len].Attackrange[n] = -2;
							}

						}

					}
					if (en[len].Attacktimer > 0)
					{
						--en[len].Attacktimer;
						for (int n = 0; n < 3; n++)
						{
							DrawBox(en[len].Attackrange[n] + *scrollX, 380, en[len].Attackrange[n] + *scrollX + 5, 380 + 10, GetColor(255, 100, 100), TRUE);

						}
					}
				}
				break;

				case 3:
					en[len].Attackrange[0] = en[len].enemyX;
					en[len].Attackrange[1] = en[len].enemyY;
					if (en[len].AttackSustain[0] < -1)
					{
						en[len].AttackSustain[0] = 0;
					}

					if (en[len].AttackSustain[0] < 100)
					{
						++en[len].AttackSustain[0];

						DrawBox(en[len].Attackrange[0] * 20 + *scrollX - en[len].AttackSustain[0], en[len].Attackrange[1] * 20 - en[len].AttackSustain[0], en[len].Attackrange[0] * 20 + *scrollX + 5 + en[len].AttackSustain[0], en[len].Attackrange[1] * 20 + en[len].AttackSustain[0] + 5, GetColor(25, 100, 100), TRUE);
						DrawBox(en[len].Attackrange[0] * 20 + *scrollX - 100, en[len].Attackrange[1] * 20 - 100, en[len].Attackrange[0] * 20 + *scrollX + 5 + 100, en[len].Attackrange[1] * 20 + 100, GetColor(255, 100, 100), FALSE);
						//当たり判定
						if ((en[len].Attackrange[0] * 20 + *scrollX - en[len].AttackSustain[0] <= *PlayerX + 20) && (*PlayerX <= en[len].Attackrange[0] * 20 + *scrollX + 5 + en[len].AttackSustain[0]) && (en[len].Attackrange[1] * 20 - en[len].AttackSustain[0] <= *PlayerY + 20) && (*PlayerY <= en[len].Attackrange[1] * 20 + en[len].AttackSustain[0] + 5) && (mi[0].Playerinvincible == 0))
						{
							--mi[0].Playerlife;
							mi[0].Playerinvincible = 1;
							mi[0].Playerinvincibletime = PLAYERINVINCIBLETIMENUMBER;
							//攻撃中断
							//初期化
							en[len].Attackmiddle = -1;
							en[len].AttackSustain[0] = -2;
							en[len].Attackrange[0] = -2;
						}
					}
					if (en[len].AttackSustain[0] == 100)
					{
						//初期化
						en[len].Attackmiddle = -1;
						en[len].AttackSustain[0] = -2;
						en[len].Attackrange[0] = -2;
					}
					break;

				case 4:
				
					if (en[len].Attackrange[0] < -1)
					{
						en[len].Attackrange[1] = en[len].enemyX;     //今の敵のx軸
						en[len].Attackrange[0] = *PlayerY;          //プレイヤーy軸取得
						en[len].AttackSustain[0] = 0;               //攻撃継続時間初期化
					}
					//攻撃継続時間が280よりも小さいとき
					if (en[len].AttackSustain[0] < 280)
					{
						//敵のy軸がプレイヤーのy軸と違うとき
						if (!(en[len].enemyY*20 == en[len].Attackrange[0]))
						{
							//プレイヤーが敵の上にいた場合
							if (en[len].enemyY*20 > en[len].Attackrange[0])
							{
								en[len].enemyY -= 0.1;
							}
							//プレイヤーが敵の下にいた場合
							if (en[len].enemyY*20 < en[len].Attackrange[0])
							{
								en[len].enemyY += 0.1;
							}

						}
						else
						{
							if (en[len].enemydirection == RIGHT)
							{
								en[len].enemyX += 0.1;
							}
							if (en[len].enemydirection == LEFT)
							{
								en[len].enemyX -= 0.1;
							}
						}
						++en[len].AttackSustain[0];
					}
					else
					{
						//値初期化
						en[len].AttackSustain[0] = -2;
						en[len].Attackrange[0] = -2;
						en[len].Attackrange[1] = -2;
						en[len].Attackmiddle = -1;
					}
				break;

				case 5:
					if (en[len].Attackrange[0] < -1)
					{
						en[len].Attackrange[1] = en[len].enemyX;     //今の敵のx軸
						en[len].Attackrange[0] = *PlayerY;          //プレイヤーy軸取得
						en[len].AttackSustain[0] = 0;               //攻撃継続時間初期化
					}
					
						//敵のy軸がプレイヤーのy軸と違うとき
						if (!(en[len].enemyY * 20 == en[len].Attackrange[0]))
						{
							//プレイヤーが敵の上にいた場合
							if (en[len].enemyY * 20 > en[len].Attackrange[0])
							{
								--en[len].enemyY;
							}
							//プレイヤーが敵の下にいた場合
							if (en[len].enemyY * 20 < en[len].Attackrange[0])
							{
								++en[len].enemyY;
							}

						}
						else
						{
							//攻撃継続時間が280よりも小さいとき
							if (en[len].AttackSustain[0] < 280)
							{
								++en[len].AttackSustain[0];
								if ((en[len].AttackSustain[0] > 0)&&(en[len].AttackSustain[0]  < 60))
								{
									DrawBox((en[len].enemyX + 1) * 20 + *scrollX, (en[len].enemyY + 1) * 20, (en[len].enemyX + 1) * 20 + 5 + *scrollX, (en[len].enemyY + 1) * 20 + 10, GetColor(255,100,100), TRUE);
								}
								if(en[len].AttackSustain[0] >= 60)
								{
									DrawBox((en[len].enemyX + 1) * 20 + *scrollX, (en[len].enemyY + 1) * 20 + 10, (en[len].enemyX + 1) * 20 + 5 + *scrollX, 380, GetColor(255, 100, 100), TRUE);
									//当たり判定
									if (((en[len].enemyX+1)*20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (en[len].enemyX+1)*20 + *scrollX + 5) && ((en[len].enemyY +1)*20 +10 <= *PlayerY + 20) && (*PlayerY <= 380) && (mi[0].Playerinvincible == 0))
									{
										--mi[0].Playerlife;
										mi[0].Playerinvincible = 1;
										mi[0].Playerinvincibletime = PLAYERINVINCIBLETIMENUMBER;
										//攻撃中断
										//初期化

										en[len].Attackmiddle = -1;
										en[len].AttackSustain[0] = -2;
									    en[len].Attackrange[0] = -2;
										
									}
								}
							}
							else
							{
								//値初期化
								en[len].AttackSustain[0] = -2;
								en[len].Attackrange[0] = -2;
								en[len].Attackrange[1] = -2;
								en[len].Attackmiddle = -1;
							}
						}
						
					
					break;

				}
				//}

			}
			if (en[len].starttime > 0)
			{
				--en[len].starttime;
			}
			//敵との当たり判定
			if ((en[len].enemyX * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (en[len].enemyX + 1) * 20 + *scrollX) && (en[len].enemyY * 20 <= *PlayerY + 20) && (*PlayerY <= (en[len].enemyY + 1) * 20) && (mi[0].Playerinvincible == 0))
			{
				--mi[0].Playerlife;
				mi[0].Playerinvincible = 1;
				mi[0].Playerinvincibletime = PLAYERINVINCIBLETIMENUMBER;
				if (en[len].enemytype == 4)
				{
					//値初期化
					en[len].AttackSustain[0] = -2;
					en[len].Attackrange[0] = -2;
					en[len].Attackrange[1] = -2;
					en[len].Attackmiddle = -1;
				}
			}

		}


		for (int men = 0; men < 32; men++)
		{
			if (!(en[men].enemyballetX < -1))
			{
				if ((en[men].enemyballetX == 32) || (en[men].enemyballetX == 0) || (en[men].enemyballetY == 0) || (en[men].enemyballetY == 24))
				{
					//初期化
					en[men].enemyballetX = -2;
					en[men].enemyballetY = -2;
					en[men].enemydirection = -2;
				}
				if (en[men].enemydirection == RIGHT)
				{
					en[men].enemyballetX++;
				}
				if (en[men].enemydirection == LEFT)
				{
					en[men].enemyballetX--;
				}
				//弾描画
				
				DrawRotaGraph(en[men].enemyballetX * 20 + *scrollX, en[men].enemyballetY * 20, 0.2f, 0, im->gh[12], TRUE);
				//当たり判定
				if ((en[men].enemyballetX * 20 + *scrollX <= *PlayerX + 20) && (*PlayerX <= (en[men].enemyballetX + 1) * 20 + *scrollX) && (en[men].enemyballetY * 20 <= *PlayerY + 20) && (*PlayerY <= (en[men].enemyballetY + 1) * 20) && (mi[0].Playerinvincible == 0))
				{
					--mi[0].Playerlife;
					mi[0].Playerinvincible = 1;
					mi[0].Playerinvincibletime = PLAYERINVINCIBLETIMENUMBER;
					//攻撃中断
					//初期化
					en[men].enemyballetX = -2;
					en[men].enemyballetY = -2;
					en[men].enemydirection = -2;
				}
			}

		}

	
}


//敵画像表示
void judgement(ENEMY *en,int *brox,MOJI*mi,int *scrollX,int *scrollY,IMAGE *im)
{


	for (int len = 0; len < 32; len++)
	{
		//敵画像描画
		//敵タイプ1
			if (en[len].enemytype == 1)
			{
				
				DrawExtendGraph(en[len].enemyX * 20 + *scrollX, en[len].enemyY * 20, (en[len].enemyX + 1) * 20 + *scrollX, (en[len].enemyY + 1) * 20,im->gh[4], TRUE);
			}
			//敵タイプ2
			if (en[len].enemytype == 2)
			{
				if (en[len].enemydirection == RIGHT)
				{
		
					DrawRotaGraph((en[len].enemyX+1) * 20-5 + *scrollX, (en[len].enemyY+1) * 20-10, 0.2f, 0, im->gh[7], TRUE);
				}
				if (en[len].enemydirection == LEFT)
				{
					DrawRotaGraph((en[len].enemyX+2) * 20-5 + *scrollX, (en[len].enemyY+1) * 20-10, 0.2f, 0, im->gh[8], TRUE);
				}
			}
			//敵タイプ3
			if (en[len].enemytype == 3)
			{
				if (en[len].enemydirection == RIGHT)
				{
					DrawRotaGraph(en[len].enemyX * 20 + *scrollX, en[len].enemyY * 20, 0.2f, 0, im->gh[10], TRUE);
					DrawBox(en[len].enemyX * 20 + *scrollX, en[len].enemyY * 20, (en[len].enemyX + 1) * 20 + *scrollX, (en[len].enemyY + 1)*20, GetColor(255, 255, 255), TRUE);
				}
				if (en[len].enemydirection == LEFT)
				{
					DrawRotaGraph(en[len].enemyX * 20+10 + *scrollX, en[len].enemyY * 20+10, 0.2f, 0, im->gh[9], TRUE);
					


				}
			}
			//敵タイプ4
			if (en[len].enemytype == 4)
			{
				DrawRotaGraph(en[len].enemyX * 20+10 + *scrollX, en[len].enemyY * 20+10, 0.2f, 0, im->gh[11], TRUE);
				

			}
			if (en[len].enemytype == 5)
			{
				DrawRotaGraph(en[len].enemyX * 20 + *scrollX, en[len].enemyY * 20, 0.2f, 0, im->gh[36], TRUE);

			}
			//敵タイプ11
			if (en[len].enemytype == 11)
			{
				DrawRotaGraph(en[len].enemyX * 20 + *scrollX, en[len].enemyY * 20, 0.2f, 0, im->gh[24], TRUE);

			}
		
	
	}

}


